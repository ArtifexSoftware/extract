/*
Extracts text paragraphs from low-level XML representation of text spans, e.g.
as generated by 'mutool.py draw -F raw', and creates .docx file containing the
text paragraphs.

Build and test with:
    ./scripts/ptodoc.py

Run with -h or --help to see help.

Unless otherwise stated, all functions return 0 on success or -1 with errno
set.
*/

#ifdef MEMENTO
    #include "memento.h"
#endif

#include <assert.h>
#include <errno.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>


static void debugf(const char* file, int line, const char* fn, int ln, const char* format, ...)
{
    va_list va;
    if (ln) {
        fprintf(stderr, "%s:%i:%s: ", file, line, fn);
    }
    va_start(va, format);
    vfprintf(stderr, format, va);
    va_end(va);
    if (ln && format[strlen(format)-1] != '\n') {
        fprintf(stderr, "\n");
    }
}

#define debugf(format, ...) (debugf)(__FILE__, __LINE__, __FUNCTION__, 1 /*ln*/, format, ##__VA_ARGS__)
#define debugfx(format, ...) 

/* Use this in preference to strdup() so that Memento works. */
static char* local_strdup(const char* text)
{
    size_t l = strlen(text) + 1;
    char* ret = malloc(l);
    if (!ret) return NULL;
    memcpy(ret, text, l);
    return ret;
}


/* Appends first <s_len> chars of string <s> to *p, which is assumed to have
been allocated with malloc/realloc. Returns 0, or +1 if realloc() failed. */
static int str_catl(char** p, const char* s, int s_len)
{
    int p_len = (*p) ? strlen(*p) : 0;
    char* pp = realloc(*p, p_len + s_len + 1);
    if (!pp)    return -1;
    memcpy(pp + p_len, s, s_len);
    pp[p_len + s_len] = 0;
    *p = pp;
    return 0;
}

/* Appends a char to a zero-terminated string which is assumed to have been
allocated with malloc/realloc. Returns 0, or -1 with errno set if realloc()
failed. */
static int str_catc(char** p, char c)
{
    return str_catl(p, &c, 1);
}

/* Appends a char to a zero-terminated string which is assumed to have been
allocated with malloc/realloc. Returns 0, or -1 with errno set if realloc()
failed. */
static int str_cat(char** p, const char* s)
{
    return str_catl(p, s, strlen(s));
}

/* std::string in C. */
typedef struct
{
    char*   chars;  /* NULL or zero-terminated. */
    int     chars_num; /* Length of string pointed to by .chars. */
} string_t;

void string_init(string_t* string)
{
    string->chars = NULL;
    string->chars_num = 0;
}

void string_free(string_t* string)
{
    free(string->chars);
    string_init(string);
}

static int string_catl(string_t* string, const char* s, int s_len)
{
    char* chars = realloc(string->chars, string->chars_num + s_len + 1);
    if (!chars)    return -1;
    memcpy(chars + string->chars_num, s, s_len);
    chars[string->chars_num + s_len] = 0;
    string->chars = chars;
    string->chars_num += s_len;
    return 0;
}

static int string_catc(string_t* string, char c)
{
    return string_catl(string, &c, 1);
}

static int string_cat(string_t* string, const char* s)
{
    return string_catl(string, s, strlen(s));
}

/* Reads bytes until EOF and returns zero-terminated string in memory allocated
with realloc(). If error, we return NULL with errno set. */
static char* read_all(FILE* in)
{
    char*   ret = NULL;
    int     len = 0;
    size_t  delta = 128;
    for(;;) {
        char* p = realloc(ret, len + delta + 1);
        if (!p) {
            free(ret);
            return NULL;
        }
        ret = p;
        ssize_t n = fread(ret + len, 1 /*size*/, delta /*nmemb*/, in);
        len += n;
        if (feof(in)) {
            ret[len] = 0;
            return ret;
        }
        if (ferror(in)) {
            /* It's weird that fread() and ferror() don't set errno. */
            errno = EIO;
            free(ret);
            return NULL;
        }
    }
}


/* Things for representing XML. */

typedef struct {
    char*   name;
    char*   value;
} xml_attribute_t;

/* Represents a single <...> XML tag plus trailing text. */
typedef struct {
    char*               name;
    xml_attribute_t*    attributes;
    int                 attributes_num;
    string_t            text;
} xml_tag_t;

static void xml_tag_show(xml_tag_t* tag, FILE* out)
{
    fprintf(out, "tag name=%s attributes_num=%i\n", tag->name, tag->attributes_num);
    int i;
    for (i=0; i<tag->attributes_num; ++i) {
        fprintf(out, "    %s=%s\n", tag->attributes[i].name, tag->attributes[i].value);
    }
}

/* Returns pointer to value of specified attribute, or NULL if not found. */
static char* xml_tag_attributes_find(xml_tag_t* tag, const char* name)
{
    for (int i=0; i<tag->attributes_num; ++i) {
        if (!strcmp(tag->attributes[i].name, name)) {
            char* ret = tag->attributes[i].value;
            return ret;
        }
    }
    return NULL;
}

/* Finds float value of specified attribute, returning error if not found. We
use atof() and don't check for non-numeric attribute value. */
static int xml_tag_attributes_find_float(xml_tag_t* tag, const char* name, float* o_out)
{
    const char* value = xml_tag_attributes_find(tag, name);
    if (!value) {
        errno = ESRCH;
        return -1;
    }
    *o_out = atof(value);
    return 0;
}

static int xml_tag_attributes_find_int(xml_tag_t* tag, const char* name, int* o_out)
{
    const char* value = xml_tag_attributes_find(tag, name);
    if (!value) {
        errno = ESRCH;
        return -1;
    }
    *o_out = atoi(value);
    return 0;
}

static int xml_tag_attributes_append(xml_tag_t* tag, char* name, char* value)
{
    xml_attribute_t* a = realloc(
            tag->attributes,
            (tag->attributes_num+1) * sizeof(xml_attribute_t)
            );
    if (!a) return -1;
    tag->attributes = a;
    tag->attributes[tag->attributes_num].name = name;
    tag->attributes[tag->attributes_num].value = value;
    tag->attributes_num += 1;
    return 0;
}

/* Sets all fields to NULL, so will cause memory leaks if fields have not been
freed. */
static void xml_tag_init(xml_tag_t* tag)
{
    tag->name = NULL;
    tag->attributes = NULL;
    tag->attributes_num = 0;
    string_init(&tag->text);
}

static void xml_tag_free(xml_tag_t* tag)
{
    free(tag->name);
    int i;
    for (i=0; i<tag->attributes_num; ++i) {
        xml_attribute_t* attribute = &tag->attributes[i];
        free(attribute->name);
        free(attribute->value);
    }
    free(tag->attributes);
    string_free(&tag->text);
    xml_tag_init(tag);
}

/* Like strcmp() but also handles NULL. */
static int strcmp_null(const char* a, const char* b)
{
    if (!a && !b) return 0;
    if (!a) return -1;
    if (!b) return 1;
    return strcmp(a, b);
}

/* Compares tag name, then attributes; returns -1, 0 or +1. Does not compare
xml_tag_t::text members. */
static int compare_tags(const xml_tag_t* lhs, const xml_tag_t* rhs)
{
    int d;
    d = strcmp_null(lhs->name, rhs->name);
    if (d)  return d;
    for(int i=0;; ++i) {
        if (i >= lhs->attributes_num || i >= rhs->attributes_num) {
            break;
        }
        const xml_attribute_t* lhs_attribute = &lhs->attributes[i];
        const xml_attribute_t* rhs_attribute = &rhs->attributes[i];
        d = strcmp_null(lhs_attribute->name, rhs_attribute->name);
        if (d)  return d;
        d = strcmp_null(lhs_attribute->value, rhs_attribute->value);
        if (d)  return d;
    }
    if (lhs->attributes_num > rhs->attributes_num) return +1;
    if (lhs->attributes_num < rhs->attributes_num) return -1;
    return 0;
}



/* pparse_*(): simple XML 'pull' parser.

pparse_init() merely consumes the initial '<'; thereafter pparse_next() always
consumes the next '<' before returning the previous tag.

Opens specified file, verifies that prefix is as expected. Returns NULL if
error. */
static FILE* pparse_init(const char* path, const char* first_line)
{
    FILE* in = NULL;
    char* buffer = NULL;
    int e = 1;

    in = fopen(path, "r");
    if (!in) {
        printf("%s:%i: error: Could not open filename=%s\n",
                __FILE__, __LINE__, path);
        goto end;
    }

    if (first_line) {
        size_t first_line_len = strlen(first_line);
        buffer = malloc(first_line_len + 1);
        if (!buffer) goto end;
        
        ssize_t n = fread(buffer, first_line_len, 1 /*nmemb*/, in);
        if (n != 1) {
            printf("%s:%i: error: fread() failed. n=%zi. path='%s'\n", __FILE__, __LINE__, n, path);
            goto end;
        }
        buffer[first_line_len] = 0;
        if (strcmp(first_line, buffer)) {
            printf("Unrecognised prefix in path=%s: %s\n", path, buffer);
            errno = ESRCH;
            goto end;
        }
    }

    {
        int c = getc(in);
        if (c != '<') {
            printf("Expected '<' but found c=%i\n", c);
            goto end;
        }
    }
    e = 0;

    end:
    free(buffer);
    if (e) {
        if (in) {
            fclose(in);
            in = NULL;
        }
    }
    return in;
}

/* Returns 0 with *out containing next tag; or -1 with errno set if error; or
+1 with errno=ESRCH if EOF. *out is initially passed to xml_tag_free(), so *out
must have been initialised, e.g. by by xml_tag_init(). */
static int pparse_next(FILE* in, xml_tag_t* out)
{
    int ret = -1;
    xml_tag_free(out);

    char*   attribute_name = NULL;
    char*   attribute_value = NULL;

    xml_tag_init(out);
    char c;

    assert(in);

    /* Read tag name. */
    int i = 0;
    for( i=0;; ++i) {
        c = getc(in);
        if (c == EOF) {
            if (i == 0 && feof(in)) {
                /* Legitimate EOF. We provide a reasonable errno value if
                caller isn't expecting EOF and doesn't test explicitly for +1.
                */
                ret = +1;
                errno = ESRCH;
            }
            goto end;
        }
        if (c == '>' || c == ' ')  break;
        if (str_catc(&out->name, c)) goto end;
    }
    if (c == ' ') {

        /* Read attributes. */
        for(;;) {

            /* Read attribute name. */
            for(;;) {
                c = getc(in);
                if (c == EOF) {
                    errno = -ESRCH;
                    goto end;
                }
                if (c == '=' || c == '>' || c == ' ') break;
                if (str_catc(&attribute_name, c)) goto end;
            }
            if (c == '>') break;

            if (c == '=') {
                /* Read attribute value. */
                int quote_single = 0;
                int quote_double = 0;
                for(;;) {
                    c = getc(in);
                    if (c == '\'')      quote_single = !quote_single;
                    else if (c == '"')  quote_double = !quote_double;
                    else if (!quote_single && !quote_double
                            && (c == ' ' || c == '/' || c == '>')
                            ) {
                        /* We are at end of attribute value. */
                        break;
                    }
                    else if (c == '\\') {
                        // Escape next character.
                        c = getc(in);
                        if (c == EOF) {
                            errno = ESRCH;
                            goto end;
                        }
                    }
                    if (str_catc(&attribute_value, c)) goto end;
                }

                /* Remove any enclosing quotes. */
                int l = strlen(attribute_value);
                if (l >= 2) {
                    if (
                            (attribute_value[0] == '"' && attribute_value[l-1] == '"')
                            ||
                            (attribute_value[0] == '\'' && attribute_value[l-1] == '\'')
                            ) {
                        memmove(attribute_value, attribute_value+1, l-2);
                        attribute_value[l-2] = 0;
                    }
                }
            }

            if (xml_tag_attributes_append(out, attribute_name, attribute_value)) goto end;
            attribute_name = NULL;
            attribute_value = NULL;
            if (c == '/') c = getc(in);
            if (c == '>') break;
        }
    }

    /* Read plain text until next '<'. */
    for(;;) {
        c = getc(in);
        if (c == '<' || feof(in)) break;
        if (string_catc(&out->text, c)) goto end;
    }

    if (0) {
        debugf("text: ");
        for (const char* c = out->text.chars; *c; ++c) {
            if (*c == '\n') fputs("\\n", stderr);
            else putc(*c, stderr);
        }
        putc('\n', stderr);
    }

    ret = 0;

    if (0) {
        debugf("returning tag:\n");
        xml_tag_show(out, stderr);
    }

    end:

    free(attribute_name);
    free(attribute_value);
    if (ret) {
        xml_tag_free(out);
    }
    return ret;
}

typedef struct
{
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
} matrix_t;

float fz_matrix_expansion(matrix_t m)
{
    return sqrtf(fabsf(m.a * m.d - m.b * m.c));
}

typedef struct
{
    float x;
    float y;
} point_t;

point_t transform_vector(point_t p, matrix_t m)
{
    float x = p.x;
    p.x = x * m.a + p.y * m.c;
    p.y = x * m.b + p.y * m.d;
    return p;
}

static int s_read_matrix(const char* text, matrix_t* matrix)
{
    if (!text) {
        debugf("text is NULL in s_read_matrix()\n");
        errno = EINVAL;
        return -1;
    }
    int n = sscanf(text,
            "%f %f %f %f %f %f",
            &matrix->a,
            &matrix->b,
            &matrix->c,
            &matrix->d,
            &matrix->e,
            &matrix->f
            );
    assert(n == 6);
    return 0;
}

/* Like s_read_matrix() but only expects four values, and sets .e and .g to
zero. */
static int s_read_matrix4(const char* text, matrix_t* matrix)
{
    if (!text) {
        debugf("text is NULL in s_read_matrix4()\n");
        errno = EINVAL;
        return -1;
    }
    int n = sscanf(text,
            "%f %f %f %f",
            &matrix->a,
            &matrix->b,
            &matrix->c,
            &matrix->d
            );
    assert(n == 4);
    matrix->e = 0;
    matrix->f = 0;
    return 0;
}



/* These docx_*() functions generate docx content. Caller must call things
in a sensible order - e.g. don't call docx_paragraph_start() twice without
intervening call to docx_paragraph_finish(). */

static int docx_paragraph_start(string_t* content)
{
    return string_cat(content, "\n\n<w:p>");
}

static int docx_paragraph_finish(string_t* content)
{
    return string_cat(content, "\n</w:p>");
}

/* Starts a new run. Caller must ensure that docx_run_finish() was called to
terminate any previous run. */
static int docx_run_start(string_t* content, const char* font_name, double font_size,
        int bold, int italic)
{
    int e = 0;
    if (!e) e = string_cat(content, "\n<w:r><w:rPr><w:rFonts w:ascii=\"");
    if (!e) e = string_cat(content, font_name);
    if (!e) e = string_cat(content, "\" w:hAnsi=\"");
    if (!e) e = string_cat(content, font_name);
    if (!e) e = string_cat(content, "\"/>");
    if (!e && bold) e = string_cat(content, "<w:b/>");
    if (!e && italic) e = string_cat(content, "<w:i/>");
    if (!e) {
        char    font_size_text[32];
        snprintf(font_size_text, sizeof(font_size_text), "%.1f", font_size * 2);
        e = string_cat(content, font_size_text);
    }
    if (!e) e = string_cat(content, "\"/></w:rPr><w:t xml:space=\"preserve\">");
    assert(!e);
    return e;

}
static int docx_run_finish(string_t* content)
{
    return string_cat(content, "</w:t></w:r>");
}

static int docx_char_append_string(string_t* content, char* text)
{
    return string_cat(content, text);
}

static int docx_char_append_char(string_t* content, char c)
{
    return string_catc(content, c);
}

/* Removes last <len> chars. */
static int docx_char_truncate(string_t* content, int len)
{
    assert(len <= content->chars_num);
    content->chars_num -= len;
    content->chars[content->chars_num] = 0;
    return 0;
}

/* Removes last char if it is <c>. */
static int docx_char_truncate_if(string_t* content, char c)
{
    if (content->chars_num && content->chars[content->chars_num-1] == c) {
        docx_char_truncate(content, 1);
    }
    return 0;
}



static int local_vasprintf(char** out, const char* format, va_list va0)
{
    va_list va;

    /* Find required length. */
    va_copy(va, va0);
    int len = vsnprintf(NULL, 0, format, va);
    va_end(va);
    assert(len >= 0);
    len += 1; /* For terminating 0. */

    /* Repeat call of vnsprintf() with required buffer. */
    char* buffer = malloc(len);
    if (!buffer) {
        return -1;
    }
    va_copy(va, va0);
    int len2 = vsnprintf(buffer, len, format, va);
    va_end(va);
    assert(len2 + 1 == len);
    *out = buffer;
    return len2;
}

static int local_asprintf(char** out, const char* format, ...)
{
    va_list va;
    va_start(va, format);
    int ret = local_vasprintf(out, format, va);
    va_end(va);
    return ret;
}

static int systemf(const char* format, ...)
{
    char* command;
    va_list va;
    va_start(va, format);
    int e = local_vasprintf(&command, format, va);
    va_end(va);
    if (e < 0) return e;
    printf("running: %s\n", command);
    e = system(command);
    free(command);
    return e;
}

/*
Creates a .docx file based on a template, by inserting <content> into
word/document.xml.

content:
    E.g. from process().
path_out:
    Name of .docx file to create. Must not contain single-quote character.
path_template:
    Name of .docx file to use as a template.
preserve_dir:
    If true, we don't delete the temporary directory <path_out>.dir containing
    unzipped .docx content.

Returns 0 on success or -1 with errno set.

We use the 'zip' and 'unzip' commands.
*/
static int docx_create(string_t* content, const char* path_out, const char* path_template, int preserve_dir)
{
    assert(path_out);
    assert(path_template);

    /* This gets set to zero only if everything succeeds. */
    int ret = -1;

    char*   path_tempdir = NULL;
    char*   word_document_xml = NULL;
    char*   original = NULL;
    FILE*   f = NULL;

    int e;

    if (strchr(path_out, '\'')) {
        printf("path_out contains single-quote character: %s\n", path_out);
        errno = EINVAL;
        goto end;
    }

    if (local_asprintf(&path_tempdir, "%s.dir", path_out) < 0) goto end;
    if (systemf("rm -r '%s' 2>/dev/null", path_tempdir) < 0) goto end;

    if (mkdir(path_tempdir, 0777)) {
        debugf("Failed to create directory: %s\n", path_tempdir);
        goto end;
    }

    if (0) debugf("Unzipping template document '%s' to tempdir: %s\n", path_template, path_tempdir);
    e = systemf("unzip -q -d %s %s", path_tempdir, path_template);
    if (e) {
        debugf("Failed to unzip %s into %s\n",
                path_template, path_tempdir);
        if (e > 0) errno = EIO;
        goto end;
    }

    if (local_asprintf(&word_document_xml, "%s/word/document.xml", path_tempdir) < 0) goto end;

    debugf("Reading tempdir's word/document.xml object\n");
    f = fopen(word_document_xml, "r");
    if (!f) {
        debugf("Failed to open docx object: %s\n",
                word_document_xml);
        goto end;
    }
    original = read_all(f);
    if (!original) goto end;
    if (fclose(f)) goto end;
    f = NULL;

    const char* original_marker = "<w:body>";
    const char* original_pos = strstr(original, original_marker);
    if (!original_pos) {
        debugf("error: could not find '%s' in docx object: %s\n",
                original_marker, word_document_xml);
        errno = ESRCH;
        goto end;
    }
    original_pos += strlen(original_marker);

    if (0) printf("Writing tempdir's word/document.xml file\n");
    f = fopen(word_document_xml, "w");
    if (!f) {
        debugf("error: Failed to open .docx for writing: %s", word_document_xml);
        goto end;
    }
    if (0
            || fwrite(original, original_pos - original, 1 /*nmemb*/, f) == 0
            || fwrite(content->chars, content->chars_num, 1 /*nmemb*/, f) == 0
            || fwrite(original_pos, strlen(original_pos), 1 /*nmemb*/, f) == 0
            || fclose(f) < 0
            ) {
        debugf("error: Failed to write to: %s", word_document_xml);
        goto end;
    }
    f = NULL;

    if (0) fprintf(stderr, "Zipping tempdir to create create %s\n", path_out);
    const char* path_out_leaf = strrchr(path_out, '/');
    if (!path_out_leaf) path_out_leaf = path_out;
    e = systemf("cd %s && zip -q -r ../%s .", path_tempdir, path_out_leaf);
    if (e) {
        debugf("Zip command failed to convert '%s' directory into output file: %s",
                path_tempdir, path_out);
        if (e > 0) errno = EIO;
        goto end;
    }

    if (!preserve_dir) {
        e = systemf("rm -r '%s'", path_tempdir);
        if (e) {
            debugf("error: Failed to delete tempdir: %s", path_tempdir);
            if (e > 0) errno = EIO;
            goto end;
        }
    }

    ret = 0;

    end:
    if (path_tempdir)   free(path_tempdir);
    if (word_document_xml)  free(word_document_xml);
    if (original)   free(original);
    if (f)  fclose(f);

    return ret;
}



/* Things for direct conversion of text spans into lines and paragraphs,
without using mupdf's stext device. */

typedef struct
{
    float       x;
    float       y;
    int         gid;
    unsigned    ucs;
    float       adv;
} char_t;

static void char_init(char_t* item)
{
    item->x = 0;
    item->y = 0;
    item->gid = 0;
    item->ucs = 0;
    item->adv = 0;
}

typedef struct span_t
{
    matrix_t    ctm;
    matrix_t    trm;
    char*       font_name;
    // font size is fz_matrix_expansion(trm).
    int         font_bold;
    int         font_italic;
    int         wmode;
    char_t*     chars;
    int         chars_num;
} span_t;

const char* span_string(span_t* span)
{
    float x0 = 0;
    float y0 = 0;
    float x1 = 0;
    float y1 = 0;
    int c0 = 0;
    int c1 = 0;
    if (span->chars_num) {
        c0 = span->chars[0].ucs;
        x0 = span->chars[0].x;
        y0 = span->chars[0].y;
        c1 = span->chars[span->chars_num-1].ucs;
        x1 = span->chars[span->chars_num-1].x;
        y1 = span->chars[span->chars_num-1].y;
    }
    static string_t ret = {0};
    string_free(&ret);
    char buffer[200];
    snprintf(buffer, sizeof(buffer),
            "span %p: (%c:%f,%f)..(%c:%f,%f) font=%s:(%f,%f) wmode=%i chars_num=%i: ",
            span,
            c0, x0, y0,
            c1, x1, y1,
            span->font_name,
            span->trm.a,
            span->trm.d,
            span->wmode,
            span->chars_num
            );
    string_cat(&ret, buffer);
    int i;
    for (i=0; i<span->chars_num; ++i) {
        snprintf(buffer, sizeof(buffer), " i=%i {x=%f adv=%f}", i, span->chars[i].x, span->chars[i].adv);
        string_cat(&ret, buffer);
    }
    string_cat(&ret, ": ");
    string_catc(&ret, '"');
    for (i=0; i<span->chars_num; ++i) {
        string_catc(&ret, span->chars[i].ucs);
    }
    string_catc(&ret, '"');
    return ret.chars;
}

const char* span_string2(span_t* span)
{
    static string_t ret = {0};
    string_free(&ret);
    string_catc(&ret, '"');
    int i;
    for (i=0; i<span->chars_num; ++i) {
        string_catc(&ret, span->chars[i].ucs);
    }
    string_catc(&ret, '"');
    return ret.chars;
}

/* Appends new char_t with .ucs=c and all other fields zeroed. */
static int span_append_c(span_t* span, int c)
{
    char_t* items = realloc(span->chars, sizeof(*items) * (span->chars_num + 1));
    if (!items) return -1;
    span->chars = items;
    char_t* item = &span->chars[span->chars_num];
    span->chars_num += 1;
    char_init(item);
    item->ucs = c;
    return 0;
}

static char_t* span_char_first(span_t* span)
{
    assert(span->chars_num);
    return &span->chars[0];
}

static char_t* span_char_last(span_t* span)
{
    assert(span->chars_num);
    return &span->chars[span->chars_num-1];
}

static void span_dump(span_t* span, FILE* out)
{
    fprintf(out, "(%f,%f)..(%f,%f) '",
            span_char_first(span)->x,
            span_char_first(span)->y,
            span_char_last(span)->x,
            span_char_last(span)->y
            );
    int i;
    for(i=0; i<span->chars_num; ++i) {
        fprintf(out, "%c", span->chars[i].ucs);
    }
    fprintf(out, "'");
}


/* List of spans that are aligned on same line. */
typedef struct
{
    span_t**    spans;
    int         spans_num;
} line_t;

static const char* line_string(line_t* line)
{
    static string_t ret = {0};
    char    buffer[32];
    string_free(&ret);
    snprintf(buffer, sizeof(buffer), "line %p spans_num=%i:", line, line->spans_num);
    string_cat(&ret, buffer);
    int i;
    for (i=0; i<line->spans_num; ++i) {
        string_cat(&ret, " ");
        string_cat(&ret, span_string(line->spans[i]));
    }
    return ret.chars;
}

static const char* line_string2(line_t* line)
{
    static string_t ret = {0};
    char    buffer[32];
    string_free(&ret);
    snprintf(buffer, sizeof(buffer), "line %p y=%f spans_num=%i:", line, line->spans[0]->chars[0].y, line->spans_num);
    string_cat(&ret, buffer);
    int i;
    for (i=0; i<line->spans_num; ++i) {
        string_cat(&ret, " ");
        string_cat(&ret, span_string2(line->spans[i]));
    }
    return ret.chars;
}

/* Returns first span in a line. */
static span_t* line_span_last(line_t* line)
{
    return line->spans[line->spans_num - 1];
}

/* Returns list span in a line. */
static span_t* line_span_first(line_t* line)
{
    return line->spans[0];
}

/* Returns first char_t in a line. */
static char_t* line_item_first(line_t* line)
{
    span_t* span = line_span_first(line);
    return span_char_first(span);
}

/* Returns last char_t in a line. */
static char_t* line_item_last(line_t* line)
{
    span_t* span = line_span_last(line);
    return span_char_last(span);
}

/* A list of lines that are aligned and adjacent to each other so as to form a
paragraph. */
typedef struct
{
    line_t**    lines;
    int         lines_num;
} para_t;

/* Returns first line in paragraph. */
static line_t* para_line_first(const para_t* para)
{
    assert(para->lines_num);
    return para->lines[0];
}

/* Returns last line in paragraph. */
static line_t* para_line_last(const para_t* para)
{
    assert(para->lines_num);
    return para->lines[ para->lines_num-1];
}



static double span_angle(span_t* span)
{
    /* Not sure whether this is right. Inclined text seems to be done by
    setting the ctm matrix, so not really sure what trm matrix does. This code
    assumes that it also inclines text, but maybe it only rotates individual
    glyphs? */
    if (span->wmode == 0) {
        return atan2(span->trm.b, span->trm.a);
    }
    else {
        return atan2(span->trm.d, span->trm.c);
    }
}

/* Returns angle of <line>. */
static double line_angle(line_t* line)
{
    /* All spans in a line must have same angle, so just use the first span. */
    assert(line->spans_num > 0);
    return span_angle(line->spans[0]);
}

/* Returns total width of span. */
double span_adv_total(span_t* span)
{
    double dx = span_char_last(span)->x - span_char_first(span)->x;
    double dy = span_char_last(span)->y - span_char_first(span)->y;
    /* We add on the advance of the last item; this avoids us returning zero if
    there's only one item. */
    double adv = span_char_last(span)->adv * fz_matrix_expansion(span->trm);
    return sqrt(dx*dx + dy*dy) + adv;
}

/* Returns distance between end of <a> and beginning of <b>. */
static double spans_adv(span_t* a_span, char_t* a, char_t* b)
{
    double delta_x = b->x - a->x;
    double delta_y = b->y - a->y;
    double s = sqrt( delta_x*delta_x + delta_y*delta_y);
    double a_size = a->adv * fz_matrix_expansion(a_span->trm);
    s -= a_size;
    return s;
}

/* Returns 1 if lines have same wmode and are at the same angle, else 0. */
static int lines_are_compatible(line_t* a, line_t* b, double angle_a, int verbose)
{
    if (a == b) return 0;
    if (!a->spans || !b->spans) return 0;
    if (line_span_first(a)->wmode != line_span_first(b)->wmode)   return 0;
    if (memcmp(
            &line_span_first(a)->ctm,
            &line_span_first(b)->ctm,
            sizeof(matrix_t)
            )) {
        if (verbose) {
            debugf("ctm's differ: \n",
                    __FILE__, __LINE__);
            debugf("    %f %f %f %f %f %f\n",
                    line_span_first(a)->ctm.a,
                    line_span_first(a)->ctm.b,
                    line_span_first(a)->ctm.c,
                    line_span_first(a)->ctm.d,
                    line_span_first(a)->ctm.e,
                    line_span_first(a)->ctm.f
                    );
            debugf("    %f %f %f %f %f %f\n",
                    line_span_first(b)->ctm.a,
                    line_span_first(b)->ctm.b,
                    line_span_first(b)->ctm.c,
                    line_span_first(b)->ctm.d,
                    line_span_first(b)->ctm.e,
                    line_span_first(b)->ctm.f
                    );
        }
        return 0;
    }
    double angle_b = span_angle(line_span_first(b));
    if (angle_b != angle_a) {
        debugf("%s:%i: angles differ\n");
        return 0;
    }
    return 1;
}

/* Creates representation of span_t's that consists of a list of line_t's.

We only join spans that are at the same angle and are aligned.

On entry:
    Original value of *o_lines and *o_lines_num are ignored.

    <spans> points to array of <spans_num> span_t*'s, each pointing to a
    span_t.

On exit:
    If we succeed, we return 0, with *o_lines pointing to array of *o_lines_num
    line_t*'s, each pointing to a line_t.

    Otherwise we return -1 with errno set. *o_lines and *o_lines_num are
    undefined.
*/
static int make_lines(span_t** spans, int spans_num, line_t*** o_lines, int* o_lines_num)
{
    int ret = -1;

    /* Make a line_t for each span. Then we will join some of these line_t's
    together before returning. */
    int     lines_num = spans_num;
    line_t** lines = NULL;

    lines = malloc(sizeof(*lines) * lines_num);
    if (!lines) goto end;

    int a;
    /* Ensure we can clean up after error. */
    for (a=0; a<lines_num; ++a) {
        lines[a] = NULL;
    }
    for (a=0; a<lines_num; ++a) {
        lines[a] = malloc(sizeof(line_t));
        if (!lines[a])  goto end;
        lines[a]->spans_num = 0;
        lines[a]->spans = malloc(sizeof(span_t*) * 1);
        if (!lines[a]->spans)   goto end;
        lines[a]->spans_num = 1;
        lines[a]->spans[0] = spans[a];
        debugfx("initial line a=%i: %s\n", a, line_string(lines[a]));
    }

    /* For each line, look for nearest aligned line, and append if found. */
    int num_joins = 0;
    for (a=0; a<lines_num; ++a) {

        line_t* line_a = lines[a];
        if (!line_a) {
            continue;
        }

        int verbose = 0;
        debugfx("a=%i: %s\n", a, line_string(line_a));
        line_t* nearest_line = NULL;
        int nearest_line_b = -1;
        double nearest_adv = 0;

        span_t* span_a = line_span_last(line_a);
        double angle_a = span_angle(span_a);

        int b;
        for (b=0; b<lines_num; ++b) {

            line_t* line_b = lines[b];
            if (!line_b) {
                continue;
            }
            if (verbose) debugf("a=%i b=%i: nearest_line_b=%i nearest_adv=%lf: %s\n",
                    a,
                    b,
                    nearest_line_b,
                    nearest_adv,
                    line_string(line_b)
                    );
            if (!lines_are_compatible(line_a, line_b, angle_a, verbose)) {
                if (verbose) debugf("not compatible\n");
                continue;
            }

            /* Find angle between last glyph of span_a and first glyph of
            span_b. This detects whether the lines are lined up with each other
            (as opposed to being at the same angle but in different lines). */
            span_t* span_b = line_span_first(line_b);
            double angle_a_b = atan2(
                    span_char_first(span_b)->y - span_char_last(span_a)->y,
                    span_char_first(span_b)->x - span_char_last(span_a)->x
                    );
            /* Might want to relax this when we test on non-horizontal lines.
            */
            const double    pi = 3.14159265;
            const double    angle_tolerance_deg = 1;
            if (fabs(angle_a_b - angle_a) * 180/pi <= angle_tolerance_deg) {
                /* Find distance between end of line_a and beginning of line_b. */
                double adv = spans_adv(span_a, span_char_last(span_a), span_char_first(span_b));
                if (0) debugf("nearest_adv=%lf. angle_a_b=%lf adv=%lf\n",
                        nearest_adv,
                        angle_a_b,
                        adv
                        );
                if (!nearest_line || adv < nearest_adv) {
                    nearest_line = line_b;
                    nearest_adv = adv;
                    nearest_line_b = b;
                }
            }
            else {
                if (verbose) debugf(
                        "angle beyond tolerance: span_a last=(%f,%f) span_b first=(%f,%f) angle_a_b=%lg angle_a=%lg span_a.trm{a=%f b=%f}\n",
                        span_char_last(span_a)->x,
                        span_char_last(span_a)->y,
                        span_char_first(span_b)->x,
                        span_char_first(span_b)->y,
                        angle_a_b * 180/pi,
                        angle_a * 180/pi,
                        span_a->trm.a,
                        span_a->trm.b
                        );
            }
        }

        if (nearest_line) {
            /* line_a and nearest_line are aligned so we can move line_b's spans on
            to the end of line_a. */
            b = nearest_line_b;
            debugf("found nearest line. a=%i b=%i\n", a, b);
            span_t* span_b = line_span_first(nearest_line);

            if (1
                    && span_char_last(span_a)->ucs != ' '
                    && span_char_first(span_b)->ucs != ' '
                    ) {
                /* Find average advance of the two adjacent spans in the two
                lines we are considering joining, so that we can decide whether
                the distance between them is large enough to merit joining with
                a space character). */
                double average_adv = (
                        (span_adv_total(span_a) + span_adv_total(span_b))
                        /
                        (span_a->chars_num + span_b->chars_num)
                        );

                int insert_space = (nearest_adv > 0.25 * average_adv);
                if (insert_space) {
                    /* Append space to span_a before concatenation. */
                    if (1) debugf("(inserted space) nearest_adv=%lf average_adv=%lf\n",
                            nearest_adv,
                            average_adv
                            );
                    char_t* p = realloc(span_a->chars, (span_a->chars_num + 1) * sizeof(char_t));
                    if (!p) goto end;
                    span_a->chars = p;
                    char_t* item = &span_a->chars[span_a->chars_num];
                    span_a->chars_num += 1;
                    bzero(item, sizeof(*item));
                    item->ucs = ' ';
                    item->adv = nearest_adv;
                }

                debugf("Joining spans a=%i b=%i:\n", a, b);
                debugf("    %s\n", span_string2(span_a));
                debugf("    %s\n", span_string2(span_b));
                if (0) {
                    /* Show details about what we're joining. */
                    debugf(
                            "joining line insert_space=%i a=%i (y=%f) to line b=%i (y=%f). nearest_adv=%lf average_adv=%lf\n",
                            insert_space,
                            a,
                            span_char_last(span_a)->y,
                            b,
                            span_char_first(span_b)->y,
                            nearest_adv,
                            average_adv
                            );
                    debugf("a: ");
                    span_dump(span_a, stderr);
                    debugf("\nb: ");
                    span_dump(span_b, stderr);
                    debugf("\n");
                }
            }

            /* We might end up with two adjacent spaces here. But removing a
            space could result in an empty line_t, which could break various
            assumptions elsewhere. */

            span_t** s = realloc(
                    line_a->spans,
                    sizeof(span_t*) * (line_a->spans_num + nearest_line->spans_num)
                    );
            if (!s) goto end;
            line_a->spans = s;
            int k;
            for (k=0; k<nearest_line->spans_num; ++k) {
                line_a->spans[ line_a->spans_num + k] = nearest_line->spans[k];
            }
            line_a->spans_num += nearest_line->spans_num;

            /* Ensure that we ignore nearest_line from now on. */
            free(nearest_line->spans);
            free(nearest_line);
            //nearest_line->spans = NULL;
            //nearest_line->spans_num = 0;
            debugf("setting line[b=%i] to NULL\n", b);
            lines[b] = NULL;

            num_joins += 1;

            if (b > a) {
                /* We haven't yet tried appending any spans to nearest_line, so
                the new extended line_a needs checking again. */
                a -= 1;
            }
            debugf("new line is:\n    %s\n", line_string2(line_a));
        }
    }

    if (1) debugf("Have made %i joins out of %i spans\n", num_joins, lines_num);

    /* Remove empty lines left behind after we appended pairs of lines. */
    int from;
    int to;
    for (from=0, to=0; from<lines_num; ++from) {
            debugf("final line from=%i: %s\n",
                    from,
                    lines[from] ? line_string(lines[from]) : "NULL"
                    );
        if (lines[from]) {
            lines[to] = lines[from];
            /*debugf("final line to=%i: %s\n",
                    to,
                    line_string(lines[to])
                    );*/
            to += 1;
        }
    }
    lines_num = to;
    line_t** l = realloc(lines, sizeof(line_t*) * lines_num);
    assert(l); /* Should always succeed because we're not increasing allocation size. */
    lines = l;

    *o_lines = lines;
    *o_lines_num = lines_num;
    ret = 0;

    end:
    if (ret) {
        /* Free everything. */
        for (a=0; a<lines_num; ++a) {
            if (lines[a])   free(lines[a]->spans);
            free(lines[a]);
        }
    }
    return ret;
}


/* Returns max font size of all span_t's in a line_t. */
static double line_font_size_max(line_t* line)
{
    double  size_max = 0;
    int i;
    for (i=0; i<line->spans_num; ++i) {
        span_t* span = line->spans[i];
        int size = fz_matrix_expansion(span->trm);
        if (size > size_max) {
            size_max = size;
        }
    }
    return size_max;
}



/* Find distance between line_a and line_b. */
/*
        _-R
     _-
    A------------_P
     \        _-
      \    _B
       \_-
        Q

AR and QBP are parallel, and are the lines of text a and b
respectively.

AQB is a right angle.
APB and PAR are both angle_a.

We need to find AQ.
*/
static double line_distance(double ax, double ay, double bx, double by, double angle)
{
    double dx = bx - ax;
    double dy = by - ay;
    double angle1 = atan2(-dy, dx); /* angle BAP */
    double angle2 = angle + angle1; /* angle BAR = ABQ */
    double distance1 = sqrt(dx*dx + dy*dy); /* AB */
    double distance = distance1 * sin(angle2); /* AQ */
    if (angle == 0) {
        /* Sanity check if AR and QBP are horizontal. */
        assert(fabs(distance - (ay - by)) < 0.1);
    }
    return distance;
}

/* A comparison function for use with qsort(), for sorting paragraphs within a
page. */
static int paras_cmp(const void* a, const void* b)
{
    para_t* const* a_para = a;
    para_t* const* b_para = b;
    line_t* a_line = para_line_first(*a_para);
    line_t* b_line = para_line_first(*b_para);

    span_t* a_span = line_span_first(a_line);
    span_t* b_span = line_span_first(b_line);

    /* If ctm matrices differ, always return this diff first. */
    int d = memcmp(&a_span->ctm, &b_span->ctm, sizeof(a_span->ctm));
    if (d)  return d;

    double a_angle = line_angle(a_line);
    double b_angle = line_angle(b_line);
    if (fabs(a_angle - b_angle) > 3.14/2) {
        /* Give up if more than 90 deg. */
        return 0;
    }
    double angle = (a_angle + b_angle) / 2;
    double ax = line_item_first(a_line)->x;
    double ay = line_item_first(a_line)->y;
    double bx = line_item_first(b_line)->x;
    double by = line_item_first(b_line)->y;
    double distance = line_distance(ax, ay, bx, by, angle);
    if (distance > 0)   return -1;
    if (distance < 0)   return +1;
    return 0;
}

/* Creates a representation of line_t's that consists of a list of para_t's.

We only join lines that are at the same angle and are adjacent.

On entry:
    Original value of *o_paras and *o_paras_num are ignored.

    <lines> points to array of <lines_num> line_t*'s, each pointing to a
    line_t.

On exit:
    On sucess, returns zero, *o_paras points to array of *o_paras_num
    para_t*'s, each pointing to a para_t. In the array, para_t's with same
    angle are sorted.

    On failure, returns -1 with errno set. *o_paras and *o_paras_num are
    undefined.
*/
static int make_paras(line_t** lines, int lines_num, para_t*** o_paras, int* o_paras_num)
{
    int ret = -1;
    para_t** paras = NULL;

    /* Start off with a para_t for each line_t. */
    int paras_num = lines_num;
    paras = malloc(sizeof(*paras) * paras_num);
    if (!paras) goto end;
    int a;
    /* Ensure we can clean up after error. */
    for (a=0; a<paras_num; ++a) {
        paras[a] = NULL;
    }
    for (a=0; a<paras_num; ++a) {
        paras[a] = malloc(sizeof(para_t));
        if (!paras[a]) goto end;
        paras[a]->lines_num = 0;
        paras[a]->lines = malloc(sizeof(line_t*) * 1);
        if (!paras[a]->lines) goto end;
        paras[a]->lines_num = 1;
        paras[a]->lines[0] = lines[a];
    }

    int num_joins = 0;
    for (a=0; a<paras_num; ++a) {

        para_t* para_a = paras[a];
        if (!para_a) {
            /* This para is empty - already been appended to a different para. */
            continue;
        }

        para_t* nearest_para = NULL;
        int nearest_para_b = -1;
        double nearest_para_distance = -1;
        assert(para_a->lines_num > 0);

        line_t* line_a = para_line_last(para_a);
        double angle_a = line_angle(line_a);

        /* Look for nearest run that could be appended to run_a. */
        int b;
        for (b=0; b<paras_num; ++b) {
            para_t* para_b = paras[b];
            if (!para_b) {
                /* This para is empty - already been appended to a different
                para. */
                continue;
            }
            line_t* line_b = para_line_first(para_b);
            if (!lines_are_compatible(line_a, line_b, angle_a, 0)) {
                continue;
            }

            double ax = line_item_last(line_a)->x;
            double ay = line_item_last(line_a)->y;
            double bx = line_item_first(line_b)->x;
            double by = line_item_first(line_b)->y;
            double distance = line_distance(ax, ay, bx, by, angle_a);

            if (distance > 0) {
                if (nearest_para_distance == -1 || distance < nearest_para_distance) {
                    nearest_para_distance = distance;
                    nearest_para_b = b;
                    nearest_para = para_b;
                }
            }
        }

        if (nearest_para) {
            line_t* line_b = para_line_first(nearest_para);
            double line_b_size = line_font_size_max(para_line_first(nearest_para));
            if (0) debugf(
                    "joing paragraphs. a=(%lf,%lf) b=(%lf,%lf) nearest_para_distance=%lf line_b_size=%lf\n",
                    line_item_last(line_a)->x,
                    line_item_last(line_a)->y,
                    line_item_first(line_b)->x,
                    line_item_first(line_b)->y,
                    nearest_para_distance,
                    line_b_size
                    );
            if (nearest_para_distance < 1.5 * line_b_size) {
                /* Join these two para_t's. */
                span_t* a_span = line_span_last(line_a);
                if (span_char_last(a_span)->ucs == '-') {
                    /* remove trailing '-' at end of prev line. */
                    a_span->chars_num -= 1;
                }
                else {
                    /* Insert space before joining adjacent lines. */
                    if (span_append_c(line_span_last(line_a), ' ')) goto end;
                }

                int a_lines_num_new = para_a->lines_num + nearest_para->lines_num;
                line_t** l = realloc(para_a->lines, sizeof(line_t*) * a_lines_num_new);
                if (!l) goto end;
                para_a->lines = l;
                int i;
                for (i=0; i<nearest_para->lines_num; ++i) {
                    para_a->lines[para_a->lines_num + i] = nearest_para->lines[i];
                }
                para_a->lines_num = a_lines_num_new;

                /* Ensure that we skip nearest_para in future. */
                free(nearest_para->lines);
                free(nearest_para);
                paras[nearest_para_b] = NULL;
                //nearest_para->lines = NULL;
                //nearest_para->lines_num = 0;

                num_joins += 1;
                if (0) debugf("have joined para a=%i to snearest_para_b=%i\n", a, nearest_para_b);

                if (nearest_para_b > a) {
                    /* We haven't yet tried appending any paras to
                    nearest_para_b, so the new extended para_a needs checking
                    again. */
                    a -= 1;
                }
            }
        }
    }

    /* Remove empty paragraphs. */
    int from;
    int to;
    for (from=0, to=0; from<paras_num; ++from) {
        if (paras[from]) {
            paras[to] = paras[from];
            to += 1;
        }
    }
    if (0) debugf("paras_num=%i => %i\n", paras_num, to);
    paras_num = to;
    para_t** p = realloc(paras, sizeof(para_t*) * paras_num);
    assert(p); /* Should always succeed because we're not increasing allocation size. */
    paras = p;

    /* Sort paragraphs. */
    qsort(paras, paras_num, sizeof(para_t*), paras_cmp);

    *o_paras = paras;
    *o_paras_num = paras_num;
    ret = 0;
    if (1) debugf("Have made %i joins out of %i paras\n", num_joins, paras_num);

    end:

    if (ret) {
        for (a=0; a<paras_num; ++a) {
            if (paras[a])   free(paras[a]->lines);
            free(paras[a]);
        }
        free(paras);
    }
    return ret;
}



typedef struct
{
    span_t**    spans;
    int         spans_num;

    /*  lines->... eventually points to items in .spans. */
    line_t**    lines;
    int         lines_num;

    /*  pras->... eventually points to items in .lines. */
    para_t**    paras;
    int         paras_num;
} page_t;

static void page_init(page_t* page)
{
    page->spans = NULL;
    page->spans_num = 0;
    page->lines = NULL;
    page->lines_num = 0;
    page->paras = NULL;
    page->paras_num = 0;
}

static void page_free(page_t* page)
{
    if (!page) return;

    int s;
    for (s=0; s<page->spans_num; ++s) {
        span_t* span = page->spans[s];
        if (span) {
            free(span->chars);
            free(span->font_name);
        }
        free(span);
    }
    free(page->spans);

    int l;
    for (l=0; l<page->lines_num; ++l) {
        line_t* line = page->lines[l];
        free(line->spans);
        free(line);
        /* We don't free line->spans->chars[] because already freed via
        page->spans. */
    }
    free(page->lines);

    int p;
    for (p=0; p<page->paras_num; ++p) {
        para_t* para = page->paras[p];
        if (para) free(para->lines);
        free(para);
    }
    free(page->paras);
}

/* Appends new span_ to a page_t; returns NULL with errno set on error. */
static span_t* page_span_append(page_t* page)
{
    span_t* span = malloc(sizeof(*span));
    if (!span) return NULL;
    span->font_name = NULL;
    span->chars = NULL;
    span->chars_num = 0;
    span_t** s = realloc(page->spans, sizeof(*s) * (page->spans_num + 1));
    if (!s) {
        free(span);
        return NULL;
    }
    page->spans = s;
    page->spans[page->spans_num] = span;
    page->spans_num += 1;
    return span;
}

typedef struct {
    page_t**    pages;
    int         pages_num;
} document_t;

static void document_init(document_t* document)
{
    document->pages = NULL;
    document->pages_num = 0;
}

/* Appends new page_t to a document_t; returns NULL with errno set on error. */
static page_t* document_page_append(document_t* document)
{
    page_t* page = malloc(sizeof(page_t));
    if (!page) return NULL;
    page->spans = NULL;
    page->spans_num = 0;
    page->lines = NULL;
    page->lines_num = 0;
    page->paras = NULL;
    page->paras_num = 0;
    page_t** pages = realloc(document->pages, sizeof(page_t*) * (document->pages_num + 1));
    if (!pages) {
        free(page);
        return NULL;
    }
    document->pages = pages;
    page_init(page);
    document->pages[document->pages_num] = page;
    document->pages_num += 1;
    return page;
}

static void document_free(document_t* document)
{
    int p;
    for (p=0; p<document->pages_num; ++p) {
        page_t* page = document->pages[p];
        page_free(page);
        free(page);
    }
    free(document->pages);
    document->pages = NULL;
    document->pages_num = 0;
}

/* Does preliminary processing of the end of the last spen in a page; intended
to be called as we load span information.

Looks at last two char_t's in last span_t of <page>, and either leaves
unchanged, or removes space in last-but-one position, or moves last char_t into
a new span_t. */
static int page_span_end_clean( page_t* page)
{
    int ret = -1;
    assert(page->spans_num);
    span_t* span = page->spans[page->spans_num-1];
    assert(span->chars_num);
    char_t* char_ = &span->chars[span->chars_num];
    if (span->chars_num == 1) {
        return 0;
    }

    float font_size = fz_matrix_expansion(span->trm);

    point_t dir;
    if (span->wmode) {
        dir.x = 0;
        dir.y = 1;
    }
    else {
        dir.x = 1;
        dir.y = 0;
    }
    dir = transform_vector(dir, span->trm);

    float x = char_[-2].x + char_[-2].adv * dir.x;
    float y = char_[-2].y + char_[-2].adv * dir.y;

    float err_x = (char_[-1].x - x) / font_size;
    float err_y = (char_[-1].y - y) / font_size;
    if (0
            && span->chars_num >= 2
            && char_[-2].ucs == ' '
            && char_[-1].ucs == 'y'
            ) {
         if (0) debugf("*** ucs=%c pos=(%f, %f) char_=(%f, %f) err=(%f, %f) adv=%f\n",
                char_[-1].ucs,
                x, y,
                char_[-1].x, char_[-1].y,
                err_x, err_y,
                char_[-1].adv
                );
        debugf("*** span is: %s\n",
                span_string(span)
                );
        debugf("x=%f char_->x=%f err_x=%f. char_->x-char_[-1].x=%f char_->adv=%f\n",
                x,
                char_[-1].x,
                err_x,
                char_[-1].x-char_[-2].x,
                char_[-1].adv
                );
    }
    
    if (span->chars_num >= 2 && span->chars[span->chars_num-2].ucs == ' ') {
        int remove_penultimate_space = 0;
        if (err_x < -span->chars[span->chars_num-2].adv / 2
                && err_x > -span->chars[span->chars_num-2].adv
                ) {
            remove_penultimate_space = 1;
        }
        if ((char_[-1].x - char_[-2].x) / font_size < char_[-1].adv / 10) {
            debugf("removing penultimate space because space very narrow:"
                    "char_[-1].x-char_[-2].x=%f font_size=%f char_[-1].adv=%f\n",
                    char_[-1].x-char_[-2].x,
                    font_size,
                    char_[-1].adv
                    );
            remove_penultimate_space = 1;
        }
        if (remove_penultimate_space) {
            /* This character overlaps with previous space
            character. We discard previous space character - these
            sometimes seem to appear in the middle of words for some
            reason. */
            debugf("removing space before final char in: %s", span_string(span));
            span->chars[span->chars_num-2] = span->chars[span->chars_num-1];
            span->chars_num -= 1;
            debugf("span is now:                         %s", span_string(span));
            return 0;
        }
    }
    else if (fabs(err_x) > 0.01 || fabs(err_y) > 0.01) {
        /* This character doesn't seem to be a continuation of
        previous characters, so split into two spans. This often
        splits text incorrectly, but this is corrected later when
        we join spans into lines. */
        if (1) {
            debugf("Splitting last char into new span. font_size=%f dir.x=%f x=%f err=(%f, %f) pos=(%f, %f): %s\n",
                    font_size,
                    dir.x,
                    x,
                    err_x, err_y,
                    x, y,
                    span_string(span)
                    );
        }
        span_t* span2 = page_span_append(page);
        if (!span2) goto end;
        *span2 = *span;
        span2->font_name = local_strdup(span->font_name);
        if (!span2->font_name) goto end;
        span2->chars_num = 1;
        span2->chars = malloc(sizeof(char_t) * span2->chars_num);
        if (!span2->chars) goto end;
        span2->chars[0] = char_[-1];
        span->chars_num -= 1;
        return 0;
    }
    ret = 0;
    end:
    return ret;
}

/* Reads from 'raw' device output into document_t. */
static int read_spans_raw(const char* path, document_t *document)
{
    int ret = -1;

    FILE* in = NULL;
    document_init(document);

    xml_tag_t   tag;
    xml_tag_init(&tag);

    in = pparse_init(path, "<?xml version=\"1.0\"?>\n");
    if (!in) {
        debugf("Failed to open: %s\n", path);
        goto end;
    }
    /* Data read from <path> is expected to be XML looking like:

    <page>
        <span>
            <span_item ...>
            <span_item ...>
            ...
        </span>
        <span>
            ...
        </span>
        ...
    </page>
    <page>
        ...
    </page>
    ...

    We convert this into a list of page_t's, each containing a list of
    span_t's, each containing a list of span_element_t's.

    While doing this, we do some within-span processing:
        We remove spurious spaces.
        We split spans in two where there seem to be large gaps.
    */
    for(;;) {
        int e = pparse_next(in, &tag);
        if (e == 1) break; /* EOF. */
        if (e) goto end;
        if (strcmp(tag.name, "page")) {
            debugf("Expected <page> but tag.name='%s'\n", tag.name);
            errno = ESRCH;
            goto end;
        }
        if (0) debugf("loading spans for page %i...\n", document->pages_num);
        page_t* page = document_page_append(document);
        if (!page) goto end;

        for(;;) {
            if (pparse_next(in, &tag)) goto end;
            if (!strcmp(tag.name, "/page")) {
                break;
            }
            if (strcmp(tag.name, "span")) {
                debugf("Expected <span> but tag.name='%s'\n", tag.name);
                errno = ESRCH;
                goto end;
            }

            span_t* span = page_span_append(page);
            if (!span) goto end;

            s_read_matrix(xml_tag_attributes_find(&tag, "ctm"), &span->ctm);
            s_read_matrix(xml_tag_attributes_find(&tag, "trm"), &span->trm);
            char* f = xml_tag_attributes_find(&tag, "font_name");
            char* ff = strchr(f, '+');
            if (ff)  f = ff + 1;
            span->font_name = local_strdup(f);
            if (!span->font_name) goto end;
            span->font_bold = strstr(span->font_name, "-Bold") ? 1 : 0;
            span->font_italic = strstr(span->font_name, "-Oblique") ? 1 : 0;
            if (xml_tag_attributes_find_int(&tag, "wmode", &span->wmode)) goto end;

            for(;;) {
                if (pparse_next(in, &tag)) goto end;
                if (!strcmp(tag.name, "/span")) {
                    break;
                }
                if (strcmp(tag.name, "span_item")) {
                    errno = ESRCH;
                    debugf("Expected <span_item> but tag.name='%s'\n", tag.name);
                    goto end;
                }
                if (span_append_c(span, 0 /*c*/)) goto end;
                char_t* char_ = &span->chars[ span->chars_num-1];
                if (xml_tag_attributes_find_float(&tag, "x", &char_->x)) goto end;
                if (xml_tag_attributes_find_float(&tag, "y", &char_->y)) goto end;
                if (xml_tag_attributes_find_float(&tag, "adv", &char_->adv)) goto end;
                if (xml_tag_attributes_find_int(&tag, "gid", &char_->gid)) goto end;
                if (xml_tag_attributes_find_int(&tag, "ucs", &char_->ucs)) goto end;

                if (page_span_end_clean(page)) goto end;
                span = page->spans[page->spans_num-1];
            }
            xml_tag_free(&tag);
        }
        if (0) debugf("page=%i page->num_spans=%i\n", document->pages_num, page->spans_num);
    }

    ret = 0;

    end:
    xml_tag_free(&tag);
    if (in) {
        fclose(in);
        in = NULL;
    }

    if (ret) {
        debugf("read_spans1() returning error\n");
        document_free(document);
    }

    return ret;
}


/* Reads from 'raw' device output into document_t. */
static int read_spans_gs(const char* path, document_t *document)
{
    int ret = -1;

    FILE* in = NULL;
    document_init(document);

    xml_tag_t   tag;
    xml_tag_init(&tag);

    in = pparse_init(path, NULL);
    if (!in) {
        debugf("Failed to open: %s\n", path);
        goto end;
    }

    for(;;) {
        int e = pparse_next(in, &tag);
        if (e == 1) break; /* EOF. */
        if (e) goto end;
        if (strcmp(tag.name, "page")) {
            debugf("Expected <page> but tag.name='%s'\n", tag.name);
            errno = ESRCH;
            goto end;
        }
        if (0) debugf("loading spans for page %i...\n", document->pages_num);
        page_t* page = document_page_append(document);
        if (!page) goto end;

        for(;;) {
            if (pparse_next(in, &tag)) goto end;
            if (!strcmp(tag.name, "/page")) {
                break;
            }
            if (strcmp(tag.name, "span")) {
                debugf("Expected <span> but tag.name='%s'\n", tag.name);
                errno = ESRCH;
                goto end;
            }

            span_t* span = page_span_append(page);
            /* we ignore the span's bbox.
                if (s_read_matrix4(xml_tag_attributes_find(&tag, "bbox"), &span->ctm)) goto end;
            */
            bzero(&span->ctm, sizeof(span->ctm));
            float font_size;
            if (xml_tag_attributes_find_float(&tag, "size", &font_size)) goto end;
            span->trm.a = font_size;
            span->trm.b = 0;
            span->trm.c = 0;
            span->trm.d = font_size;
            char* f = xml_tag_attributes_find(&tag, "font");
            char* ff = strchr(f, '+');
            if (ff)  f = ff + 1;
            span->font_name = local_strdup(f);
            if (!span->font_name) goto end;
            span->font_bold = strstr(span->font_name, "-Bold") ? 1 : 0;
            span->font_italic = strstr(span->font_name, "-Oblique") ? 1 : 0;
            span->wmode = 0;

            if (0) debugf("new span, font_size=%f font_name=%s\n",
                    font_size,
                    span->font_name
                    );
            for(;;) {
                if (pparse_next(in, &tag)) goto end;
                if (!strcmp(tag.name, "/span")) {
                    break;
                }
                if (strcmp(tag.name, "char")) {
                    debugf("Expected <char> but tag.name='%s'\n", tag.name);
                    errno = ESRCH;
                    goto end;
                }
                if (span_append_c(span, 0 /*c*/)) goto end;
                char_t* char_ = &span->chars[ span->chars_num-1];
                matrix_t    bbox;
                if (s_read_matrix4(xml_tag_attributes_find(&tag, "bbox"), &bbox)) goto end;
                char_->x = bbox.a;
                char_->y = -bbox.b;
                //char_->adv = (bbox.c - bbox.a) / font_size;
                if (xml_tag_attributes_find_float(&tag, "adv", &char_->adv)) goto end;
                char_->adv /= font_size;
                const char* c = xml_tag_attributes_find(&tag, "c");
                if (!c) goto end;
                if (strlen(c) == 1) {
                    char_->ucs = c[0];
                }
                else if (!strcmp(c, "&quot;")) {
                    char_->ucs = '"';
                }
                else if (!strcmp(c, "&amp;")) {
                    char_->ucs = '&';
                }
                else if (!strcmp(c, "&lt;")) {
                    char_->ucs = '<';
                }
                else if (!strcmp(c, "&gt;")) {
                    char_->ucs = '>';
                }
                else if (!strcmp(c, "&apos;")) {
                    char_->ucs = '\'';
                }
                else {
                    if (sscanf(c, "&#x%x;", &char_->ucs) != 1) {
                        debugf("Failed to read hex value in c='%s'\n", c);
                        errno = EINVAL;
                        goto end;
                    }
                }
                if (0) debugf("have read x=%f y=%f c=%c\n",
                        char_->x, char_->y, char_->ucs
                        );

                if (page_span_end_clean(page)) goto end;
                span = page->spans[page->spans_num-1];
            }
            debugf("have made span: %s", span_string2(span));
            if (span->chars_num == 2 && span->chars[0].ucs == 'y' && span->chars[1].ucs == 'a') {
                debugf("span is: %s", span_string(span));
            }
            xml_tag_free(&tag);
        }
        if (0) debugf("page=%i page->num_spans=%i\n", document->pages_num, page->spans_num);
    }

    ret = 0;

    end:
    xml_tag_free(&tag);
    if (in) {
        fclose(in);
        in = NULL;
    }

    if (ret) {
        debugf("read_spans1() returning error\n");
        document_free(document);
    }

    return ret;
}


/* Reads from mupdf's trace-device into document_t. */
static int read_spans_trace(const char* path, document_t* document)
{
    int ret = -1;
    FILE* in = NULL;

    document_init(document);

    in = pparse_init(path, "<?xml version=\"1.0\"?>\n");
    if (!in) {
        debugf("Failed to open: %s\n", path);
        goto end;
    }
    xml_tag_t   tag;
    xml_tag_init(&tag);

    int e = pparse_next(in, &tag);
    if (e) {
        debugf("Failed to read <document...> at start\n");
        goto end;
    }
        
    if (strcmp(tag.name, "document")) {
        debugf("expected '<document...>' but tag.name='%s'\n", tag.name);
        errno = ESRCH;
        goto end;
    }

    for(;;) {
        int e = pparse_next(in, &tag);
        if (e == 1) break; /* EOF. */
        if (e) goto end;
        if (!strcmp(tag.name, "/document")) {
            break;
        }
        if (strcmp(tag.name, "page")) {
            debugf("Expected <page> but tag.name='%s'\n", tag.name);
            errno = ESRCH;
            goto end;
        }
        page_t* page = document_page_append(document);
        if (!page) goto end;

        for(;;) {
            if (pparse_next(in, &tag)) goto end;
            if (!strcmp(tag.name, "/page")) {
                break;
            }
            if (strcmp(tag.name, "fill_text")) continue;
            matrix_t   ctm;
            s_read_matrix(xml_tag_attributes_find(&tag, "transform"), &ctm);

            for(;;) {
                if (pparse_next(in, &tag)) goto end;
                if (!strcmp(tag.name, "/fill_text")) {
                    break;
                }
                if (strcmp(tag.name, "span")) {
                    debugf("Expected <span...> after <fill_text>, but tag.name='%s'\n", tag.name);
                    errno = ESRCH;
                    goto end;
                }
                span_t* span = page_span_append(page);
                if (!span) goto end;
                span->ctm = ctm;
                /* trace-device appears to only write first four members of
                fz_text_span::trm, on the assumption that .e and .f are zero,
                so we use s_read_matrix4() here. */
                s_read_matrix4(xml_tag_attributes_find(&tag, "trm"), &span->trm);
                char* f = xml_tag_attributes_find(&tag, "font");
                char* ff = strchr(f, '+');
                if (ff)  f = ff + 1;
                span->font_name = local_strdup(f);
                if (!span->font_name) goto end;
                span->font_bold = strstr(span->font_name, "-Bold") ? 1 : 0;
                span->font_italic = strstr(span->font_name, "-Oblique") ? 1 : 0;
                if (xml_tag_attributes_find_int(&tag, "wmode", &span->wmode)) goto end;

                for(;;) {
                    if (pparse_next(in, &tag)) goto end;
                    if (!strcmp(tag.name, "/span")) {
                        break;
                    }
                    if (strcmp(tag.name, "g")) {
                        errno = ESRCH;
                        debugf("Expected <g> but tag.name='%s'\n", tag.name);
                        goto end;
                    }
                    if (span_append_c(span, 0 /*c*/)) goto end;
                    char_t* char_ = &span->chars[ span->chars_num-1];
                    char_->x    = atof(xml_tag_attributes_find(&tag, "x"));
                    char_->y    = atof(xml_tag_attributes_find(&tag, "y"));
                    char_->gid  = 0;
                    if (xml_tag_attributes_find_int(&tag, "ucs", &char_->ucs)) goto end;
                    if (xml_tag_attributes_find_float(&tag, "adv", &char_->adv)) goto end;

                    if (page_span_end_clean(page)) goto end;
                    span = page->spans[page->spans_num-1];
                }
            }
        }
        if (0) debugf("page=%i page->num_spans=%i\n", document->pages_num, page->spans_num);
    }

    ret = 0;

    end:
    xml_tag_free(&tag);
    if (in) {
        fclose(in);
        in = NULL;
    }

    if (ret) {
        debugf("read_spans1() returning error\n");
        document_free(document);
    }

    return ret;
}


/* Writes paragraphs from document_t into docx content. On return
*content points to zero-terminated content, allocated by realloc(). */
static int paras_to_content(document_t* document, string_t* content)
{
    int ret = -1;

    /* Write paragraphs into <content>. */
    int p;
    for (p=0; p<document->pages_num; ++p) {
        page_t* page = document->pages[p];

        const char* font_name = NULL;
        float       font_size = 0;
        int         font_bold = 0;
        int         font_italic = 0;
        int p;
        for (p=0; p<page->paras_num; ++p) {
            para_t* para = page->paras[p];
            if (0) debugf("\n[para] ");
            if (docx_paragraph_start(content)) goto end;

            int l;
            for (l=0; l<para->lines_num; ++l) {
                line_t* line = para->lines[l];
                if (0) debugf(" [line] ");
                int s;
                for (s=0; s<line->spans_num; ++s) {
                    span_t* span = line->spans[s];
                    if (0) {
                        debugf(" [span ");
                        if (!font_name || strcmp(span->font_name, font_name)) {
                            debugf("%s", span->font_name);
                        }
                        if (span->font_bold != font_bold || span->font_italic != font_italic) {
                            if (0) debugf(" %c%c",
                                    span->font_bold ? 'b':'-',
                                    span->font_italic ? 'i' : '-'
                                    );
                        }
                        debugf("]");
                    }
                    if (!font_name
                            || strcmp(span->font_name, font_name)
                            || fz_matrix_expansion(span->trm) != font_size
                            || span->font_bold != font_bold
                            || span->font_italic != font_italic
                            ) {
                        if (font_name) {
                            if (docx_run_finish(content)) goto end;
                            if (0) debugf(" [font %s:%lf:%c%c] ",
                                    span->font_name,
                                    fz_matrix_expansion(span->trm),
                                    span->font_bold ? 'b' : '-',
                                    span->font_italic ? 'i' : '-'
                                    );
                        }
                        if (0) debugf(" [%s %c%c] ",
                                span->font_name,
                                span->font_bold ? 'b':'-',
                                span->font_italic ? 'i' : '-'
                                );
                        font_name = span->font_name;
                        font_bold = span->font_bold;
                        font_italic = span->font_italic;
                        font_size = fz_matrix_expansion(span->trm);
                        if (docx_run_start(content, font_name, font_size, font_bold, font_italic)) goto end;
                    }

                    int si;
                    for (si=0; si<span->chars_num; ++si) {
                        char_t* char_ = &span->chars[si];
                        if (0) debugf("%c", char_->ucs);
                        if (0) debugf("[char_] %c (%f, %f)\n",
                                char_->ucs,
                                char_->x,
                                char_->y
                                );
                        int c = char_->ucs;
                        if (0) {}

                        /* Escape XML special characters. */
                        else if (c == '<')  docx_char_append_string(content, "&lt;");
                        else if (c == '>')  docx_char_append_string(content, "&gt;");
                        else if (c == '&')  docx_char_append_string(content, "&amp;");
                        else if (c == '"')  docx_char_append_string(content, "&quot;");
                        else if (c == '\'') docx_char_append_string(content, "&apos;");

                        /* Expand ligatures. */
                        else if (c == 0xFB00) {
                            if (docx_char_append_string(content, "ff")) goto end;
                        }
                        else if (c == 0xFB01) {
                            if (docx_char_append_string(content, "fi")) goto end;
                        }
                        else if (c == 0xFB02) {
                            if (docx_char_append_string(content, "fl")) goto end;
                        }
                        else if (c == 0xFB03) {
                            if (docx_char_append_string(content, "ffi")) goto end;
                        }
                        else if (c == 0xFB04) {
                            if (docx_char_append_string(content, "ffl")) goto end;
                        }

                        /* Output ASCII verbatim. */
                        else if (c >= 32 && c <= 127) {
                            if (docx_char_append_char(content, c)) goto end;
                        }

                        /* Escape all other characters. */
                        else {
                            char    buffer[32];
                            snprintf(buffer, sizeof(buffer), "&#x%x;", c);
                            if (docx_char_append_string(content, buffer)) goto end;
                        }
                    }
                    /* Remove any trailing '-' at end of line. */
                    if (docx_char_truncate_if(content, '-')) goto end;
                }
            }
            if (0) debugf("\n");
            if (font_name) {
                if (docx_run_finish(content)) goto end;
                font_name = NULL;
            }
            if (docx_paragraph_finish(content)) goto end;
        }
    }
    ret = 0;

    end:

    /* Free everything. */
    document_free(document);

    return ret;
}

/* Reads from intermediate data and converts into docx content. On return
*content points to zero-terminated content, allocated by realloc(). */
static int document_to_docx_content(document_t* document, string_t* content)
{
    int ret = -1;

    /* Now for each page we join spans into lines and paragraphs. A line is a
    list of spans that are at the same angle and on the same line. A paragraph
    is a list of lines that are at the same angle and close together. */
    int p;
    for (p=0; p<document->pages_num; ++p) {
        if (0) debugf("==[page %i]:\n", p);
        page_t* page = document->pages[p];

        if (make_lines(page->spans, page->spans_num, &page->lines, &page->lines_num)) goto end;

        if (make_paras(page->lines, page->lines_num, &page->paras, &page->paras_num)) goto end;
    }

    if (paras_to_content(document, content)) goto end;

    ret = 0;

    end:

    /* Free everything. */
    document_free(document);

    return ret;
}




/* Things to allow creation of a fz_context*. */


int main(int argc, char** argv)
{
    (void) str_cat;
    (void) compare_tags;
    
    const char* docx_out_path       = NULL;
    const char* input_path          = NULL;
    const char* docx_template_path  = NULL;
    const char* content_path        = NULL;
    int         preserve_dir        = 0;
    const char* method              = NULL;

    for (int i=1; i<argc; ++i) {
        const char* arg = argv[i];
        if (!strcmp(arg, "-h") || !strcmp(arg, "--help")) {
            printf(
                    "Generates a .docx file.\n"
                    "\n"
                    "Input:\n"
                    "\n"
                    "    We require a file containing XML output from: mutool draw -F <device>\n"
                    "    - where <device> is 'raw' or 'trace'.\n"
                    "\n"
                    "    We also requires a template .docx file\n"
                    "\n"
                    "Args:\n"
                    "    -c <path>\n"
                    "        If specified, we write raw .docx content to <path>; this is the\n"
                    "        text that we embed inside the template word/document.xml file\n"
                    "        when generating the .docx.\n"
                    "    -m <method>\n"
                    "        How to extract information from pdf document:\n"
                    "            raw\n"
                    "                <input-path> is from 'raw' device; use native conversion.\n"
                    "            trace\n"
                    "                <input-path> is from 'trace' device; use native conversion.\n"
                    "            gs\n"
                    "                <input-path> is from gs 'txtwrite' device; use native conversion.\n"
                    "    -i <input-path>\n"
                    "        Name of XML file containing low-level text spans.\n"
                    "    -o <docx-path>\n"
                    "        Output .docx file.\n"
                    "    -p 0|1\n"
                    "        If 1, we preserve uncompressed <docx-path>.lib/ directory.\n"
                    "    -t <docx-template>\n"
                    "        Name of docx file to use as template.\n"
                    );
        }
        else if (!strcmp(arg, "-c")) {
            content_path = argv[++i];
        }
        else if (!strcmp(arg, "-m")) {
            method = argv[++i];
        }
        else if (!strcmp(arg, "-i")) {
            input_path = argv[++i];
        }
        else if (!strcmp(arg, "-o")) {
            docx_out_path = argv[++i];
        }
        else if (!strcmp(arg, "-p")) {
            preserve_dir = atoi(argv[++i]);
        }
        else if (!strcmp(arg, "-t")) {
            docx_template_path = argv[++i];
        }
        else {
            printf("Unrecognised arg: '%s'\n", arg);
            return 1;
        }

        assert(i < argc);
    }

    assert(input_path);
    assert(docx_out_path);
    assert(docx_template_path);

    int e = -1;
    string_t content;
    string_init(&content);
    document_t  document;
    document_init(&document);

    if (!method) {
        printf("Must specify -m <method>\n");
        errno = ESRCH;
        goto end;
    }
    else if (!strcmp(method, "trace")) {
        if (read_spans_trace(input_path, &document)) {
            printf("Failed to read 'trace' output from: %s\n", input_path);
            goto end;
        }
        if (document_to_docx_content(&document, &content)) {
            printf("Failed to create docx content errno=%i: %s\n", errno, strerror(errno));
            goto end;
        }
    }
    else if (!strcmp(method, "raw")) {
        if (read_spans_raw(input_path, &document)) {
            printf("Failed to read 'raw' output from: %s\n", input_path);
            goto end;
        }
        if (document_to_docx_content(&document, &content)) {
            printf("Failed to create docx content errno=%i: %s\n", errno, strerror(errno));
            return 1;
        }
    }
    else if (!strcmp(method, "gs")) {
        if (read_spans_gs(input_path, &document)) {
            printf("Failed to read 'raw' output from: %s\n", input_path);
            goto end;
        }
        if (document_to_docx_content(&document, &content)) {
            printf("Failed to create docx content errno=%i: %s\n", errno, strerror(errno));
            return 1;
        }
    }
    else {
        printf("Unrecognised method '%s'\n", method);
        errno = ESRCH;
        goto end;
    }

    if (content_path) {
        printf("Writing content to: %s\n", content_path);
        FILE* f = fopen(content_path, "w");
        assert(f);
        fwrite(content.chars, content.chars_num, 1 /*nmemb*/, f);
        fclose(f);
    }
    printf("Creating .docx file: %s\n", docx_out_path);
    e = docx_create(&content, docx_out_path, docx_template_path, preserve_dir);

    end:

    string_free(&content);
    document_free(&document);

    if (e) {
        printf("Failed, errno: %s\n", strerror(errno));
    }
    else {
        printf("Finished.\n");
    }

    return e;
}
