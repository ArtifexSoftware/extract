/*
Extracts text paragraphs from low-level XML representation of text spans, e.g.
as generated by 'mutool.py draw -F raw', and creates .docx file containing the
text paragraphs.

Build and test with:
    ./scripts/ptodoc.py

Run with -h or --help to see help.

Unless otherwise stated, all functions return 0 on success or -1 with errno
set.
*/

#include "../../include/mupdf/memento.h"

#include "mupdf/fitz.h"
#include "mupdf/ucdn.h"

#include <pthread.h>

#include <assert.h>
#include <errno.h>
#include <math.h>
#include <float.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include <sys/stat.h>
#include <sys/types.h>


/* Crudely #include the stext-device.c code. */
#include "../fitz/stext-device.c"


/* Use this in preference to strdup() so that Memento works. */
static char* local_strdup(const char* text)
{
    size_t l = strlen(text) + 1;
    char* ret = malloc(l);
    if (!ret) return NULL;
    memcpy(ret, text, l);
    return ret;
}


/* Appends a char to a zero-terminated string which is assumed to have been
allocated with malloc/realloc. Returns 0, or -1 with errno set if realloc()
failed. */
static int str_catc(char** p, char c)
{
    int l = (*p) ? strlen(*p) : 0;
    l += 1;
    char* pp = realloc(*p, l+1);
    if (!pp)    return -1;
    *p = pp;
    (*p)[l-1] = c;
    (*p)[l] = 0;
    return 0;
}

/* Appends a string to a string. Returns 0, or +1 if realloc() failed. */
static int str_cat(char** p, const char* s)
{
    int l_old = (*p) ? strlen(*p) : 0;
    int l_new = strlen(s);
    char* pp = realloc(*p, l_old + l_new + 1);
    if (!pp)    return -1;
    memcpy(pp + l_old, s, l_new + 1);
    *p = pp;
    return 0;
}

/* std::string in C. */
typedef struct
{
    char*   chars;  /* NULL or zero-terminated. */
    int     chars_num; /* Length of string pointed to by .chars. */
} string_t;

void string_init(string_t* string)
{
    string->chars = NULL;
    string->chars_num = 0;
}

void string_free(string_t* string)
{
    free(string->chars);
    string_init(string);
}

static int string_catl(string_t* string, const char* s, int s_len)
{
    char* chars = realloc(string->chars, string->chars_num + s_len + 1);
    if (!chars)    return -1;
    memcpy(chars + string->chars_num, s, s_len+1);
    string->chars = chars;
    string->chars_num += s_len;
    return 0;
}

static int string_catc(string_t* string, char c)
{
    return string_catl(string, &c, 1);
}

static int string_cat(string_t* string, const char* s)
{
    return string_catl(string, s, strlen(s));
}

/* Reads bytes until EOF and returns zero-terminated string in memory allocated
with realloc(). If error, we return NULL with errno set. */
static char* read_all(FILE* in)
{
    char*   ret = NULL;
    int     len = 0;
    size_t  delta = 128;
    for(;;) {
        char* p = realloc(ret, len + delta + 1);
        if (!p) {
            free(ret);
            return NULL;
        }
        ret = p;
        ssize_t n = fread(ret + len, 1 /*size*/, delta /*nmemb*/, in);
        len += n;
        if (feof(in)) {
            ret[len] = 0;
            return ret;
        }
        if (ferror(in)) {
            /* It's weird that fread() and ferror() don't set errno. */
            errno = EIO;
            free(ret);
            return NULL;
        }
    }
}


/* Things for representing XML. */

typedef struct {
    char*   name;
    char*   value;
} xml_attribute_t;

/* Represents a single <...> XML tag plus trailing text. */
typedef struct {
    char*               name;
    xml_attribute_t*    attributes;
    int                 attributes_num;
    string_t            text;
} xml_tag_t;

static void xml_tag_show(xml_tag_t* tag, FILE* out)
{
    fprintf(out, "tag name=%s attributes_num=%i\n", tag->name, tag->attributes_num);
    int i;
    for (i=0; i<tag->attributes_num; ++i) {
        fprintf(out, "    %s=%s\n", tag->attributes[i].name, tag->attributes[i].value);
    }
}

/* Returns pointer to value of specified attribute, or NULL if not found. */
static char* xml_tag_attributes_find(xml_tag_t* tag, const char* name)
{
    for (int i=0; i<tag->attributes_num; ++i) {
        if (!strcmp(tag->attributes[i].name, name)) {
            char* ret = tag->attributes[i].value;
            return ret;
        }
    }
    return NULL;
}

/* Finds float value of specified attribute, returning error if not found. We
use atof() and don't check for non-numeric attribute value. */
static int xml_tag_attributes_find_float(xml_tag_t* tag, const char* name, float* o_out)
{
    const char* value = xml_tag_attributes_find(tag, name);
    if (!value) {
        errno = ESRCH;
        return -1;
    }
    *o_out = atof(value);
    return 0;
}

static int xml_tag_attributes_find_int(xml_tag_t* tag, const char* name, int* o_out)
{
    const char* value = xml_tag_attributes_find(tag, name);
    if (!value) {
        errno = ESRCH;
        return -1;
    }
    *o_out = atoi(value);
    return 0;
}

static int xml_tag_attributes_append(xml_tag_t* tag, char* name, char* value)
{
    xml_attribute_t* a = realloc(
            tag->attributes,
            (tag->attributes_num+1) * sizeof(xml_attribute_t)
            );
    if (!a) return -1;
    tag->attributes = a;
    tag->attributes[tag->attributes_num].name = name;
    tag->attributes[tag->attributes_num].value = value;
    tag->attributes_num += 1;
    return 0;
}

/* Sets all fields to NULL, so will cause memory leaks if fields have not been
freed. */
static void xml_tag_init(xml_tag_t* tag)
{
    tag->name = NULL;
    tag->attributes = NULL;
    tag->attributes_num = 0;
    string_init(&tag->text);
}

static void xml_tag_free(xml_tag_t* tag)
{
    free(tag->name);
    int i;
    for (i=0; i<tag->attributes_num; ++i) {
        xml_attribute_t* attribute = &tag->attributes[i];
        free(attribute->name);
        free(attribute->value);
    }
    free(tag->attributes);
    string_free(&tag->text);
    xml_tag_init(tag);
}

/* Like strcmp() but also handles NULL. */
static int strcmp_null(const char* a, const char* b)
{
    if (!a && !b) return 0;
    if (!a) return -1;
    if (!b) return 1;
    return strcmp(a, b);
}

/* Compares tag name, then attributes; returns -1, 0 or +1. Does not compare
xml_tag_t::text members. */
static int compare_tags(const xml_tag_t* lhs, const xml_tag_t* rhs)
{
    int d;
    d = strcmp_null(lhs->name, rhs->name);
    if (d)  return d;
    for(int i=0;; ++i) {
        if (i >= lhs->attributes_num || i >= rhs->attributes_num) {
            break;
        }
        const xml_attribute_t* lhs_attribute = &lhs->attributes[i];
        const xml_attribute_t* rhs_attribute = &rhs->attributes[i];
        d = strcmp_null(lhs_attribute->name, rhs_attribute->name);
        if (d)  return d;
        d = strcmp_null(lhs_attribute->value, rhs_attribute->value);
        if (d)  return d;
    }
    if (lhs->attributes_num > rhs->attributes_num) return +1;
    if (lhs->attributes_num < rhs->attributes_num) return -1;
    return 0;
}



/* pparse_*(): simple XML 'pull' parser.

pparse_init() merely consumes the initial '<'; thereafter pparse_next() always
consumes the next '<' before returning the previous tag.

Opens specified file, verifies that prefix is as expected. Returns NULL if
error. */
static FILE* pparse_init(const char* path)
{
    FILE* in = NULL;
    char* buffer = NULL;
    int e = 1;

    in = fopen(path, "r");
    if (!in) {
        fprintf(stderr, "%s:%i: error: Could not open mutool output filename=%s\n",
                __FILE__, __LINE__, path);
        goto end;
    }

    const char  prefix[] = "<?xml version=\"1.0\"?>\n";
    buffer = malloc(sizeof(prefix));
    if (!buffer) {
        fprintf(stderr, "%s:%i: error: malloc() failed\n", __FILE__, __LINE__);
        goto end;
    }
    ssize_t n = fread(buffer, sizeof(prefix)-1, 1 /*nmemb*/, in);
    if (n != 1) {
        fprintf(stderr, "%s:%i: error: fread() failed. n=%zi. path='%s'\n", __FILE__, __LINE__, n, path);
        goto end;
    }
    buffer[sizeof(prefix)-1] = 0;
    if (strcmp(prefix, buffer)) {
        fprintf(stderr, "Unrecognised prefix in path=%s: %s\n", path, buffer);
        goto end;
    }

    {
        int c = getc(in);
        if (c != '<') {
            fprintf(stderr, "Expected '<' but found c=%i\n", c);
            goto end;
        }
    }
    e = 0;

    end:
    free(buffer);
    if (e) {
        if (in) {
            fclose(in);
            in = NULL;
        }
    }
    return in;
}

/* Returns 0 with *out containing next tag; or -1 with errno set if error; or
+1 if EOF. *out is initially passed to xml_tag_free(), so *out must have been
initialised, e.g. by by xml_tag_init(). */
static int pparse_next(FILE* in, xml_tag_t* out)
{
    int ret = -1;
    xml_tag_free(out);

    char*   attribute_name = NULL;
    char*   attribute_value = NULL;

    xml_tag_init(out);
    char c;

    assert(in);

    /* Read tag name. */
    int i = 0;
    for( i=0;; ++i) {
        c = getc(in);
        if (c == EOF) {
            if (i == 0 && feof(in)) {
                /* Legitimate EOF. We provide a reasonable errno value if
                caller isn't expecting EOF and doesn't test explicitly for +1.
                */
                ret = +1;
                errno = ESRCH;
            }
            goto end;
        }
        if (c == '>' || c == ' ')  break;
        if (str_catc(&out->name, c)) goto end;
    }
    if (c == ' ') {

        /* Read attributes. */
        for(;;) {

            /* Read attribute name. */
            for(;;) {
                c = getc(in);
                if (c == EOF) goto end;
                if (c == '=' || c == '>' || c == ' ') break;
                if (str_catc(&attribute_name, c)) goto end;
            }
            if (c == '>') break;

            if (c == '=') {
                /* Read attribute value. */
                int quote_single = 0;
                int quote_double = 0;
                for(;;) {
                    c = getc(in);
                    if (c == '\'')      quote_single = !quote_single;
                    else if (c == '"')  quote_double = !quote_double;
                    else if (!quote_single && !quote_double
                            && (c == ' ' || c == '/' || c == '>')
                            ) {
                        /* We are at end of attribute value. */
                        break;
                    }
                    else if (c == '\\') {
                        // Escape next character.
                        c = getc(in);
                        if (c == EOF) goto end;
                    }
                    if (str_catc(&attribute_value, c)) goto end;
                }

                /* Remove any enclosing quotes. */
                int l = strlen(attribute_value);
                if (l >= 2) {
                    if (
                            (attribute_value[0] == '"' && attribute_value[l-1] == '"')
                            ||
                            (attribute_value[0] == '\'' && attribute_value[l-1] == '\'')
                            ) {
                        memmove(attribute_value, attribute_value+1, l-2);
                        attribute_value[l-2] = 0;
                    }
                }
            }

            if (xml_tag_attributes_append(out, attribute_name, attribute_value)) goto end;
            attribute_name = NULL;
            attribute_value = NULL;
            if (c == '/') c = getc(in);
            if (c == '>') break;
        }
    }

    /* Read plain text until next '<'. */
    for(;;) {
        c = getc(in);
        if (c == '<' || feof(in)) break;
        if (string_catc(&out->text, c)) goto end;
    }

    if (0) {
        fprintf(stderr, "text: ");
        for (const char* c = out->text.chars; *c; ++c) {
            if (*c == '\n') fputs("\\n", stderr);
            else putc(*c, stderr);
        }
        putc('\n', stderr);
    }

    ret = 0;

    if (0) {
        fprintf(stderr, "returning tag:\n");
        xml_tag_show(out, stderr);
    }

    end:

    free(attribute_name);
    free(attribute_value);
    if (ret) {
        xml_tag_free(out);
    }
    return ret;
}

static int s_read_matrix(const char* text, fz_matrix* matrix)
{
    int n = sscanf(text,
            "%f %f %f %f %f %f",
            &matrix->a,
            &matrix->b,
            &matrix->c,
            &matrix->d,
            &matrix->e,
            &matrix->f
            );
    assert(n == 6);
    return 0;
}

/* Like s_read_matrix() but only expects four values, and sets .e and .g to
zero. */
static int s_read_matrix4(const char* text, fz_matrix* matrix)
{
    int n = sscanf(text,
            "%f %f %f %f",
            &matrix->a,
            &matrix->b,
            &matrix->c,
            &matrix->d
            );
    assert(n == 4);
    matrix->e = 0;
    matrix->f = 0;
    return 0;
}



/* Reads from intermediate .xml file containing spans, into a new
fz_stext_device, which is returned.

(Wec use code directly #included from ../fitz/stext-device.c above). */

typedef struct
{
    fz_stext_page* page;
    fz_stext_device* dev;
} stext_dev_and_page;

/* Caller should clean up with:
    stext_dev_and_page dev_page = spans_to_stext_device(ctx, ...);
    ...
    fz_close_device(ctx, &dev_page.dev->super);
    fz_drop_device(ctx, &dev_page.dev->super);
    fz_drop_stext_page(ctx, dev_page.page);
*/
static stext_dev_and_page spans_to_stext_device(fz_context* ctx, const char* path)
{
    stext_dev_and_page  dev_page;
    dev_page.page = fz_new_stext_page(ctx, fz_infinite_rect);
    dev_page.dev = (void*) fz_new_stext_device(ctx, dev_page.page, NULL /*options*/);

    FILE* in = pparse_init(path);
    if (!in) {
        fprintf(stderr, "Failed to open path='%s', errno=%i\n", path, errno);
    }
    assert(in);
    int         e;
    xml_tag_t   tag;
    xml_tag_init(&tag);

    for(;;) {
        e = pparse_next(in, &tag);
        if (e) break;

        /* We essentially ignore <page> tags - not really relevant for creating
        logical runs of text etc. */
        assert(!strcmp(tag.name, "page"));

        for(;;) {
            e = pparse_next(in, &tag);
            assert(!e);
            if (!strcmp(tag.name, "/page")) {
                break;
            }
            //printf("tag.name=%s\n", tag.name);
            assert(!strcmp(tag.name, "span"));
            fz_matrix   ctm;
            fz_matrix   trm;
            s_read_matrix(xml_tag_attributes_find(&tag, "ctm"), &ctm);
            s_read_matrix(xml_tag_attributes_find(&tag, "trm"), &trm);
            const char* font_name = xml_tag_attributes_find(&tag, "font_name");
            const char* f = strchr(font_name, '+');
            if (f)  font_name = f + 1;
            int is_bold;
            int is_italic;
            xml_tag_attributes_find_int(&tag, "is_bold", &is_bold);
            xml_tag_attributes_find_int(&tag, "is_italic", &is_italic);
            char* font_name2 = local_strdup(font_name);
            //if (is_bold) str_cat(&font_name2, "-Bold");
            //if (is_italic) str_cat(&font_name2, "-Oblique");

            //fz_font* font = fz_new_builtin_font(ctx, font_name, is_bold, is_italic);
            fz_font* font = malloc(sizeof(*font));
            bzero(font, sizeof(*font));
            snprintf(font->name, sizeof(font->name), "%s", font_name2);
            free(font_name2);

            int wmode;
            xml_tag_attributes_find_int(&tag, "wmode", &wmode);

            #if 0
            if (0) fprintf(stderr, "%s:%i: trm={%f %f %f %f %f %f} ctm={%f %f %f %f %f %f} trm2={%f %f %f %f %f %f}\n",
                    __FILE__, __LINE__,
                    trm.a,
                    trm.b,
                    trm.c,
                    trm.d,
                    trm.e,
                    trm.f,
                    ctm.a,
                    ctm.b,
                    ctm.c,
                    ctm.d,
                    ctm.e,
                    ctm.f,
                    trm2.a,
                    trm2.b,
                    trm2.c,
                    trm2.d,
                    trm2.e,
                    trm2.f
                    );
            #endif

            for(;;) {
                e = pparse_next(in, &tag);
                assert(!e);
                //printf("tag.name=%s\n", tag.name);
                if (!strcmp(tag.name, "/span")) {
                    break;
                }
                assert(!strcmp(tag.name, "span_item"));

                float x;
                float y;
                int gid;
                int ucs;
                float adv;
                xml_tag_attributes_find_float(&tag, "x", &x);
                xml_tag_attributes_find_float(&tag, "y", &y);
                xml_tag_attributes_find_float(&tag, "adv", &adv);
                xml_tag_attributes_find_int(&tag, "gid", &gid);
                xml_tag_attributes_find_int(&tag, "ucs", &ucs);

                fz_matrix trm2 = trm;
                trm2.e = x;
                trm2.f = y;
                trm2 = fz_concat(trm2, ctm);

                /* This is a hack to prevent fz_add_stext_char() eventually
                getting SEGV in fz_font_ascender(). */
                static fz_buffer*   t3procs[256];
                font->t3procs = t3procs;

                fz_add_stext_char(ctx, dev_page.dev, font, ucs, gid, trm2, adv, wmode);

                /* As of 2020-07-17, fz_add_stext_char() doesn't keep <font>
                so we leak font here. We could keep track of fonts, but prob
                better to fix stext to keep/drop and simply drop <font> here.
                */
            }
        }
    }
    fclose(in);

    return dev_page;
}

/* Like fprintf() but returns quietly if <out> is NULL. */
static int safe_fprintf(FILE* out, const char* format, ...)
{
    if ( !out)  return 0;
    va_list va;
    va_start(va, format);
    int ret = vfprintf(out, format, va);
    va_end(va);
    return ret;
}

/* Detailed XML dump of the entire structured text data */

static void page_to_xml(fz_context* ctx, fz_stext_page *page, int id, FILE* out_xml)
{
    fz_stext_block *block;
    fz_stext_line *line;
    fz_stext_char *ch;

    safe_fprintf(out_xml, "<page id=\"page%d\" width=\"%g\" height=\"%g\">\n", id,
        page->mediabox.x1 - page->mediabox.x0,
        page->mediabox.y1 - page->mediabox.y0);

    for (block = page->first_block; block; block = block->next)
    {
        switch (block->type)
        {
        case FZ_STEXT_BLOCK_TEXT:
            safe_fprintf(out_xml, "<block bbox=\"%g %g %g %g\">\n",
                    block->bbox.x0, block->bbox.y0, block->bbox.x1, block->bbox.y1);
            for (line = block->u.t.first_line; line; line = line->next)
            {
                fz_font *font = NULL;
                float size = 0;
                const char *name = NULL;

                safe_fprintf(out_xml, "<line bbox=\"%g %g %g %g\" wmode=\"%d\" dir=\"%g %g\">\n",
                        line->bbox.x0, line->bbox.y0, line->bbox.x1, line->bbox.y1,
                        line->wmode,
                        line->dir.x, line->dir.y);

                for (ch = line->first_char; ch; ch = ch->next)
                {
                    if (ch->font != font || ch->size != size)
                    {
                        if (font)
                            safe_fprintf(out_xml, "</font>\n");
                        font = ch->font;
                        size = ch->size;
                        safe_fprintf(out_xml, "<font name=\"%s\" size=\"%g\">\n", font->name, size);
                    }
                    safe_fprintf(out_xml, "<char quad=\"%g %g %g %g %g %g %g %g\" x=\"%f\" y=\"%g\" color=\"#%06x\" c=\"",
                            ch->quad.ul.x, ch->quad.ul.y,
                            ch->quad.ur.x, ch->quad.ur.y,
                            ch->quad.ll.x, ch->quad.ll.y,
                            ch->quad.lr.x, ch->quad.lr.y,
                            ch->origin.x, ch->origin.y,
                            ch->color);
                    switch (ch->c)
                    {
                    case '<': safe_fprintf(out_xml, "&lt;"); break;
                    case '>': safe_fprintf(out_xml, "&gt;"); break;
                    case '&': safe_fprintf(out_xml, "&amp;"); break;
                    case '"': safe_fprintf(out_xml, "&quot;"); break;
                    case '\'': safe_fprintf(out_xml, "&apos;"); break;
                    default:
                           if (ch->c >= 32 && ch->c <= 127)
                               safe_fprintf(out_xml, "%c", ch->c);
                           else
                               safe_fprintf(out_xml, "&#x%x;", ch->c);
                           break;
                    }
                    safe_fprintf(out_xml, "\"/>\n");
                }

                if (font)
                    safe_fprintf(out_xml, "</font>\n");

                safe_fprintf(out_xml, "</line>\n");
            }
            safe_fprintf(out_xml, "</block>\n");
            break;

        case FZ_STEXT_BLOCK_IMAGE:
            safe_fprintf(out_xml, "<image bbox=\"%g %g %g %g\" />\n",
                    block->bbox.x0, block->bbox.y0, block->bbox.x1, block->bbox.y1);
            break;
        }
    }
    safe_fprintf(out_xml, "</page>\n");
}












/* These docx_*() functions generate docx content. Caller must call things
in a sensible order - e.g. don't call docx_paragraph_start() twice without
intervening call to docx_paragraph_finish(). */

static int docx_paragraph_start(string_t* content)
{
    return string_cat(content, "\n\n<w:p>");
}

static int docx_paragraph_finish(string_t* content)
{
    return string_cat(content, "\n</w:p>");
}

/* Starts a new run. Caller must ensure that docx_run_finish() was called to
terminate any previous run. */
static int docx_run_start(string_t* content, const char* font_name, double font_size,
        int bold, int italic)
{
    int e = 0;
    if (!e) e = string_cat(content, "\n<w:r><w:rPr><w:rFonts w:ascii=\"");
    if (!e) e = string_cat(content, font_name);
    if (!e) e = string_cat(content, "\" w:hAnsi=\"");
    if (!e) e = string_cat(content, font_name);
    if (!e) e = string_cat(content, "\"/>");
    if (!e && bold) e = string_cat(content, "<w:b/>");
    if (!e && italic) e = string_cat(content, "<w:i/>");
    if (!e) {
        char    font_size_text[32];
        snprintf(font_size_text, sizeof(font_size_text), "%.1f", font_size * 2);
        e = string_cat(content, font_size_text);
    }
    if (!e) e = string_cat(content, "\"/></w:rPr><w:t xml:space=\"preserve\">");
    assert(!e);
    return e;

}
static int docx_run_finish(string_t* content)
{
    return string_cat(content, "</w:t></w:r>");
}

static int docx_char_append_string(string_t* content, char* text)
{
    return string_cat(content, text);
}

static int docx_char_append_char(string_t* content, char c)
{
    return string_catc(content, c);
}

/* Removes last <len> chars. */
static int docx_char_truncate(string_t* content, int len)
{
    assert(len <= content->chars_num);
    content->chars_num -= len;
    content->chars[content->chars_num] = 0;
    return 0;
}

/* Removes last char if it is <c>. */
static int docx_char_truncate_if(string_t* content, char c)
{
    if (content->chars_num && content->chars[content->chars_num-1] == c) {
        docx_char_truncate(content, 1);
    }
    return 0;
}


/* Creates docx content from fz_stext_page, applying some heuristics to clean
up the output, and makes *content point to zero-terminated text allocated by
realloc(). */
static int page_to_docx_content(fz_context* ctx, fz_stext_page *page, string_t* content)
{
    fz_stext_block* block;
    for (block = page->first_block; block; block = block->next)
    {
        if (block->type == FZ_STEXT_BLOCK_TEXT) {

            docx_paragraph_start(content);

            fz_stext_char *ch_prev = NULL;
            fz_font *font = NULL;
            float font_size = 0;

            fz_stext_line* line;
            for (line = block->u.t.first_line; line; line = line->next)
            {
                /* If previous line did not end with hyphen, append a space. */
                if (ch_prev && ch_prev->c != '-') {
                    docx_char_append_char(content, ' ');
                }

                fz_stext_char *ch;
                for (ch = line->first_char; ch; ch = ch->next)
                {
                    if (ch->font != font || ch->size != font_size)
                    {
                        if (font) {
                            docx_run_finish(content);
                            font = NULL;
                            font_size = 0;
                        }

                        font = ch->font;
                        font_size = ch->size;
                        int bold = strstr(font->name, "-Bold") ? 1 : 0;
                        int italic = strstr(font->name, "-Oblique") ? 1 : 0;

                        docx_run_start(content, font->name, font_size, bold, italic);
                        ch_prev = NULL; /* Need to avoid removing prev space. */
                    }

                    /* Discard spaces which overlap with the following
                    character - these sometimes seem to appear in the
                    middle of words. */
                    if (ch_prev && ch_prev->c == ' ') {
                        /* We get slight rounding errors, so sometimes the
                        normal behaviour where quads are adjacent ends up with
                        them slightly overlapping, so we use a small correction
                        to avoid spurious removal of legitimate spaces. */
                        if (ch_prev->quad.ur.x - 0.001 > ch->quad.ul.x) {
                            const char* tail = content->chars;
                            if (content->chars_num > 20) {
                                tail = content->chars + content->chars_num - 20;
                            }
                            if (0) fprintf(stderr, "removing space:\n"
                                    "    ch_prev->quad=(ul=(%f, %f) ur=(%f, %f) ll==(%f, %f) lr==(%f, %f)\n"
                                    "         ch->quad=(ul=(%f, %f) ur=(%f, %f) ll==(%f, %f) lr==(%f, %f)\n"
                                    "    ch->c=%c\n"
                                    "    tail='%s'\n"
                                    ,
                                    ch_prev->quad.ul.x,
                                    ch_prev->quad.ul.y,
                                    ch_prev->quad.ur.x,
                                    ch_prev->quad.ur.y,
                                    ch_prev->quad.ll.x,
                                    ch_prev->quad.ll.y,
                                    ch_prev->quad.lr.x,
                                    ch_prev->quad.lr.y,
                                    ch->quad.ul.x,
                                    ch->quad.ul.y,
                                    ch->quad.ur.x,
                                    ch->quad.ur.y,
                                    ch->quad.ll.x,
                                    ch->quad.ll.y,
                                    ch->quad.lr.x,
                                    ch->quad.lr.y,
                                    ch->c,
                                    tail
                                    );

                            docx_char_truncate(content, 1);
                        }
                    }

                    if (0) {}
                    else if (ch->c == '<')  docx_char_append_string(content, "&lt;");
                    else if (ch->c == '>')  docx_char_append_string(content, "&gt;");
                    else if (ch->c == '&')  docx_char_append_string(content, "&amp;");
                    else if (ch->c == '"')  docx_char_append_string(content, "&quot;");
                    else if (ch->c == '\'') docx_char_append_string(content, "&apos;");
                    else if (ch->c >= 32 && ch->c <= 127) docx_char_append_char(content, ch->c);
                    else {
                        char    buffer[32];
                        snprintf(buffer, sizeof(buffer), "&#x%x;", ch->c);
                        docx_char_append_string(content, buffer);
                    }

                    ch_prev = ch;
                }
                /* Remove any trailing '-' at end of line. */
                docx_char_truncate_if(content, '-');
            }

            if (font) {
                docx_run_finish(content);
                font = NULL;
            }
            docx_paragraph_finish(content);
        }
    }
    return 0;
}

static int local_vasprintf(char** out, const char* format, va_list va0)
{
    va_list va;

    /* Find required length. */
    va_copy(va, va0);
    int len = vsnprintf(NULL, 0, format, va);
    va_end(va);
    assert(len >= 0);
    len += 1; /* For terminating 0. */

    /* Repeat call of vnsprintf() with required buffer. */
    char* buffer = malloc(len);
    if (!buffer) {
        return -1;
    }
    va_copy(va, va0);
    int len2 = vsnprintf(buffer, len, format, va);
    va_end(va);
    assert(len2 + 1 == len);
    *out = buffer;
    return len2;
}

static int local_asprintf(char** out, const char* format, ...)
{
    va_list va;
    va_start(va, format);
    int ret = local_vasprintf(out, format, va);
    va_end(va);
    return ret;
}

static int systemf(const char* format, ...)
{
    char* command;
    va_list va;
    va_start(va, format);
    int e = local_vasprintf(&command, format, va);
    va_end(va);
    if (e < 0) return e;
    fprintf(stderr, "running: %s\n", command);
    e = system(command);
    free(command);
    return e;
}

/*
Creates a .docx file based on a template, by inserting <content> into
word/document.xml.

content:
    E.g. from process().
path_out:
    Name of .docx file to create. Must not contain single-quote character.
path_template:
    Name of .docx file to use as a template.
preserve_dir:
    If true, we don't delete the temporary directory <path_out>.dir containing
    unzipped .docx content.

Returns 0 on success or -1 with errno set.

We use the 'zip' and 'unzip' commands.
*/
static int docx_create(string_t* content, const char* path_out, const char* path_template, int preserve_dir)
{
    assert(path_out);
    assert(path_template);

    /* This gets set to zero only if everything succeeds. */
    int ret = -1;

    char*   path_tempdir = NULL;
    char*   word_document_xml = NULL;
    char*   original = NULL;
    FILE*   f = NULL;

    int e;

    if (strchr(path_out, '\'')) {
        fprintf(stderr, "path_out contains single-quote character: %s\n", path_out);
        errno = EINVAL;
        goto end;
    }

    if (local_asprintf(&path_tempdir, "%s.dir", path_out) < 0) goto end;
    if (systemf("rm -r '%s' 2>/dev/null", path_tempdir) < 0) goto end;

    if (mkdir(path_tempdir, 0777)) {
        fprintf(stderr, "%s:%i: Failed to create directory: %s\n",
                __FILE__, __LINE__, path_tempdir);
        goto end;
    }

    if (0) fprintf(stderr, "Unzipping template document '%s' to tempdir: %s\n", path_template, path_tempdir);
    e = systemf("unzip -q -d %s %s", path_tempdir, path_template);
    if (e) {
        fprintf(stderr, "%s:%i: Failed to unzip %s into %s\n",
                __FILE__, __LINE__, path_template, path_tempdir);
        if (e > 0) errno = EIO;
        goto end;
    }

    if (local_asprintf(&word_document_xml, "%s/word/document.xml", path_tempdir) < 0) goto end;

    if (0) fprintf(stderr, "Reading tempdir's word/document.xml object\n");
    f = fopen(word_document_xml, "r");
    if (!f) {
        fprintf(stderr, "%s:%i: Failed to open docx object: %s\n",
                __FILE__, __LINE__, word_document_xml);
        goto end;
    }
    original = read_all(f);
    if (!original) goto end;
    if (fclose(f)) goto end;
    f = NULL;

    const char* original_marker = "<w:body>";
    const char* original_pos = strstr(original, original_marker);
    if (!original_pos) {
        fprintf(stderr, "%s:%i: error: could not find '%s' in docx object: %s\n",
                __FILE__, __LINE__, original_marker, word_document_xml);
        errno = ESRCH;
        goto end;
    }
    original_pos += strlen(original_marker);

    if (0) fprintf(stderr, "Writing tempdir's word/document.xml file\n");
    f = fopen(word_document_xml, "w");
    if (!f) {
        fprintf(stderr, "%s:%i: error: Failed to open .docx for writing: %s",
                __FILE__, __LINE__, word_document_xml);
        goto end;
    }
    if (0
            || fwrite(original, original_pos - original, 1 /*nmemb*/, f) == 0
            || fwrite(content->chars, content->chars_num, 1 /*nmemb*/, f) == 0
            || fwrite(original_pos, strlen(original_pos), 1 /*nmemb*/, f) == 0
            || fclose(f) < 0
            ) {
        fprintf(stderr, "%s:%i: error: Failed to write to: %s",
                __FILE__, __LINE__, word_document_xml);
        goto end;
    }
    f = NULL;

    if (0) fprintf(stderr, "Zipping tempdir to create create %s\n", path_out);
    const char* path_out_leaf = strrchr(path_out, '/');
    if (!path_out_leaf) path_out_leaf = path_out;
    e = systemf("cd %s && zip -q -r ../%s .", path_tempdir, path_out_leaf);
    if (e) {
        fprintf(stderr, "%s:%i: error: Zip command failed to convert '%s' directory into output file: %s",
                __FILE__, __LINE__, path_tempdir, path_out);
        if (e > 0) errno = EIO;
        goto end;
    }

    if (!preserve_dir) {
        e = systemf("rm -r '%s'", path_tempdir);
        if (e) {
            fprintf(stderr, "%s:%i: error: Failed to delete tempdir: %s",
                    __FILE__, __LINE__, path_tempdir);
            if (e > 0) errno = EIO;
            goto end;
        }
    }

    ret = 0;

    end:
    if (path_tempdir)   free(path_tempdir);
    if (word_document_xml)  free(word_document_xml);
    if (original)   free(original);
    if (f)  fclose(f);

    return ret;
}



/* Things for direct conversion of text spans into lines and paragraphs,
without using mupdf's stext device. */

typedef struct
{
    float   x;
    float   y;
    int     gid;
    int     ucs;
    float   adv;
} char_t;

static void char_init(char_t* item)
{
    item->x = 0;
    item->y = 0;
    item->gid = 0;
    item->ucs = 0;
    item->adv = 0;
}

typedef struct span_t
{
    fz_matrix   ctm;
    fz_matrix   trm;
    char*       font_name;
    // font size is fz_matrix_expansion(trm).
    int         font_bold;
    int         font_italic;
    int         wmode;
    char_t*     chars;
    int         chars_num;
} span_t;

/* Appends new char_t with .ucs=c and all other fields zeroed. */
static int span_append_c(span_t* span, int c)
{
    char_t* items = realloc(span->chars, sizeof(*items) * (span->chars_num + 1));
    if (!items) return -1;
    span->chars = items;
    char_t* item = &span->chars[span->chars_num];
    span->chars_num += 1;
    char_init(item);
    item->ucs = c;
    return 0;
}

static char_t* span_char_first(span_t* span)
{
    assert(span->chars_num);
    return &span->chars[0];
}

static char_t* span_char_last(span_t* span)
{
    assert(span->chars_num);
    return &span->chars[span->chars_num-1];
}

static void span_dump(span_t* span, FILE* out)
{
    fprintf(out, "(%f,%f)..(%f,%f) '",
            span_char_first(span)->x,
            span_char_first(span)->y,
            span_char_last(span)->x,
            span_char_last(span)->y
            );
    int i;
    for(i=0; i<span->chars_num; ++i) {
        fprintf(out, "%c", span->chars[i].ucs);
    }
    fprintf(out, "'");
}


/* List of spans that are aligned on same line. */
typedef struct
{
    span_t**    spans;
    int         spans_num;
} line_t;

/* Returns first span in a line. */
static span_t* line_span_last(line_t* line)
{
    return line->spans[line->spans_num - 1];
}

/* Returns list span in a line. */
static span_t* line_span_first(line_t* line)
{
    return line->spans[0];
}

/* Returns first char_t in a line. */
static char_t* line_item_first(line_t* line)
{
    span_t* span = line_span_first(line);
    return span_char_first(span);
}

/* Returns last char_t in a line. */
static char_t* line_item_last(line_t* line)
{
    span_t* span = line_span_last(line);
    return span_char_last(span);
}

/* A list of lines that are aligned and adjacent to each other so as to form a
paragraph. */
typedef struct
{
    line_t**    lines;
    int         lines_num;
} para_t;

/* Returns first line in paragraph. */
static line_t* para_line_first(const para_t* para)
{
    assert(para->lines_num);
    return para->lines[0];
}

/* Returns last line in paragraph. */
static line_t* para_line_last(const para_t* para)
{
    assert(para->lines_num);
    return para->lines[ para->lines_num-1];
}



static double span_angle(span_t* span)
{
    /* Not sure whether this is right. Inclined text seems to be done by
    setting the ctm matrix, so not really sure what trm matrix does. This code
    assumes that it also inclines text, but maybe it only rotates individual
    glyphs? */
    if (span->wmode == 0) {
        return atan2(span->trm.b, span->trm.a);
    }
    else {
        return atan2(span->trm.d, span->trm.c);
    }
}

/* Returns angle of <line>. */
static double line_angle(line_t* line)
{
    /* All spans in a line must have same angle, so just use the first span. */
    assert(line->spans_num > 0);
    return span_angle(line->spans[0]);
}

/* Returns total width of span. */
double span_adv_total(span_t* span)
{
    double dx = span_char_last(span)->x - span_char_first(span)->x;
    double dy = span_char_last(span)->y - span_char_first(span)->y;
    /* We add on the advance of the last item; this avoids us returning zero if
    there's only one item. */
    double adv = span_char_last(span)->adv * fz_matrix_expansion(span->trm);
    return sqrt(dx*dx + dy*dy) + adv;
}

/* Returns distance between end of <a> and beginning of <b>. */
static double spans_adv(span_t* a_span, char_t* a, char_t* b)
{
    double delta_x = b->x - a->x;
    double delta_y = b->y - a->y;
    double s = sqrt( delta_x*delta_x + delta_y*delta_y);
    double a_size = a->adv * fz_matrix_expansion(a_span->trm);
    s -= a_size;
    return s;
}

/* Returns 1 if lines have same wmode and are at the same angle, else 0. */
static int lines_are_compatible(line_t* a, line_t* b, double angle_a)
{
    if (a == b) return 0;
    if (!a->spans || !b->spans) return 0;
    if (line_span_first(a)->wmode != line_span_first(b)->wmode)   return 0;
    if (memcmp(
            &line_span_first(a)->ctm,
            &line_span_first(b)->ctm,
            sizeof(fz_matrix)
            )) {
        return 0;
    }
    double angle_b = span_angle(line_span_first(b));
    if (angle_b != angle_a) return 0;
    return 1;
}

/* Creates representation of span_t's that consists of a list of line_t's.

We only join spans that are at the same angle and are aligned.

On entry:
    Original value of *o_lines and *o_lines_num are ignored.

    <spans> points to array of <spans_num> span_t*'s, each pointing to a
    span_t.

On exit:
    If we succeed, we return 0, with *o_lines pointing to array of *o_lines_num
    line_t*'s, each pointing to a line_t.

    Otherwise we return -1 with errno set. *o_lines and *o_lines_num are
    undefined.
*/
static int make_lines(span_t** spans, int spans_num, line_t*** o_lines, int* o_lines_num)
{
    int ret = -1;

    /* Make a line_t for each span. Then we will join some of these line_t's
    together before returning. */
    int     lines_num = spans_num;
    line_t** lines = NULL;

    lines = malloc(sizeof(*lines) * lines_num);
    if (!lines) goto end;

    int a;
    /* Ensure we can clean up after error. */
    for (a=0; a<lines_num; ++a) {
        lines[a] = NULL;
    }
    for (a=0; a<lines_num; ++a) {
        lines[a] = malloc(sizeof(line_t));
        if (!lines[a])  goto end;
        lines[a]->spans_num = 0;
        lines[a]->spans = malloc(sizeof(span_t*) * 1);
        if (!lines[a]->spans)   goto end;
        lines[a]->spans_num = 1;
        lines[a]->spans[0] = spans[a];
    }

    /* For each line, look for nearest aligned line, and append if found. */
    int num_joins = 0;
    for (a=0; a<lines_num; ++a) {

        line_t* line_a = lines[a];
        if (!line_a) {
            continue;
        }
        //if (!line_a->spans) {
        //    /* This line is empty - already been appended to a different line. */
        //    continue;
        //}

        line_t* nearest_line = NULL;
        int nearest_line_b = -1;
        double nearest_adv = 0;

        span_t* span_a = line_span_last(line_a);
        double angle_a = span_angle(span_a);

        int b;
        for (b=0; b<lines_num; ++b) {

            line_t* line_b = lines[b];
            if (!line_b) continue;

            if (!lines_are_compatible(line_a, line_b, angle_a)) {
                continue;
            }

            /* Find angle between last glyph of span_a and first glyph of
            span_b. This detects whether the lines are lined up with each other
            (as opposed to being at the same angle but in different lines). */
            span_t* span_b = line_span_first(line_b);
            double angle_a_b = atan2(
                    span_char_first(span_b)->y - span_char_last(span_a)->y,
                    span_char_first(span_b)->x - span_char_last(span_a)->x
                    );
            /* Might want to relax this when we test on non-horizontal lines.
            */
            const double    angle_tolerance_deg = 1;
            if (fabs(angle_a_b - angle_a) * 180/3.14 <= angle_tolerance_deg) {
                /* Find distance between end of line_a and beginning of line_b. */
                double adv = spans_adv(span_a, span_char_last(span_a), span_char_first(span_b));
                if (!nearest_line || adv < nearest_adv) {
                    nearest_line = line_b;
                    nearest_adv = adv;
                    nearest_line_b = b;
                }
            }
        }

        if (nearest_line) {

            /* line_a and nearest_line are aligned so we can move line_b's spans on
            to the end of line_a. */

            span_t* span_b = line_span_first(nearest_line);

            if (1
                    && span_char_last(span_a)->ucs != ' '
                    && span_char_first(span_b)->ucs != ' '
                    ) {
                /* Find average advance of the two adjacent spans in the two
                lines we are considering joining, so that we can decide whether
                the distance between them is large enough to merit joining with
                a space character). */
                double average_adv = (
                        (span_adv_total(span_a) + span_adv_total(span_b))
                        /
                        (span_a->chars_num + span_b->chars_num)
                        );

                int insert_space = (nearest_adv > 0.25 * average_adv);
                if (insert_space) {
                    /* Append space to span_a before concatenation. */
                    if (0) fprintf(stderr, "(inserted space)\n");
                    char_t* p = realloc(span_a->chars, (span_a->chars_num + 1) * sizeof(char_t));
                    if (!p) goto end;
                    span_a->chars = p;
                    char_t* item = &span_a->chars[span_a->chars_num];
                    span_a->chars_num += 1;
                    bzero(item, sizeof(*item));
                    item->ucs = ' ';
                    item->adv = nearest_adv;
                }

                if (0) {
                    /* Show details about what we're joining. */
                    fprintf(stderr,
                            "joining line insert_space=%i a=%i (y=%f) to line nearest_line_b=%i (y=%f). nearest_adv=%lf average_adv=%lf\n",
                            insert_space,
                            a,
                            span_char_last(span_a)->y,
                            nearest_line_b,
                            span_char_first(span_b)->y,
                            nearest_adv,
                            average_adv
                            );
                    fprintf(stderr, "a: ");
                    span_dump(span_a, stderr);
                    fprintf(stderr, "\nb: ");
                    span_dump(span_b, stderr);
                    fprintf(stderr, "\n");
                }
            }

            /* We might end up with two adjacent spaces here. But removing a
            space could result in an empty line_t, which could break various
            assumptions elsewhere. */

            span_t** s = realloc(
                    line_a->spans,
                    sizeof(span_t*) * (line_a->spans_num + nearest_line->spans_num)
                    );
            if (!s) goto end;
            line_a->spans = s;
            int k;
            for (k=0; k<nearest_line->spans_num; ++k) {
                line_a->spans[ line_a->spans_num + k] = nearest_line->spans[k];
            }
            line_a->spans_num += nearest_line->spans_num;

            /* Ensure that we ignore nearest_line from now on. */
            free(nearest_line->spans);
            free(nearest_line);
            //nearest_line->spans = NULL;
            //nearest_line->spans_num = 0;
            lines[nearest_line_b] = NULL;

            num_joins += 1;

            if (nearest_line_b > a) {
                /* We haven't yet tried appending any spans to nearest_line, so
                the new extended line_a needs checking again. */
                a -= 1;
            }
        }
    }

    if (0) fprintf(stderr, "Have made %i joins out of %i spans\n", num_joins, lines_num);

    /* Remove empty lines left behind after we appended pairs of lines. */
    int from;
    int to;
    for (from=0, to=0; from<lines_num; ++from) {
        if (lines[from]) {
            lines[to] = lines[from];
            to += 1;
        }
    }
    lines_num = to;
    line_t** l = realloc(lines, sizeof(line_t*) * lines_num);
    assert(l); /* Should always succeed because we're not increasing allocation size. */
    lines = l;

    *o_lines = lines;
    *o_lines_num = lines_num;
    ret = 0;

    end:
    if (ret) {
        /* Free everything. */
        for (a=0; a<lines_num; ++a) {
            if (lines[a])   free(lines[a]->spans);
            free(lines[a]);
        }
    }
    return ret;
}


/* Returns max font size of all span_t's in a line_t. */
static double line_font_size_max(line_t* line)
{
    double  size_max = 0;
    int i;
    for (i=0; i<line->spans_num; ++i) {
        span_t* span = line->spans[i];
        int size = fz_matrix_expansion(span->trm);
        if (size > size_max) {
            size_max = size;
        }
    }
    return size_max;
}



/* Find distance between line_a and line_b. */
/*
        _-R
     _-
    A------------_P
     \        _-
      \    _B
       \_-
        Q

AR and QBP are parallel, and are the lines of text a and b
respectively.

AQB is a right angle.
APB and PAR are both angle_a.

We need to find AQ.
*/
static double line_distance(double ax, double ay, double bx, double by, double angle)
{
    double dx = bx - ax;
    double dy = by - ay;
    double angle1 = atan2(-dy, dx); /* angle BAP */
    double angle2 = angle + angle1; /* angle BAR = ABQ */
    double distance1 = sqrt(dx*dx + dy*dy); /* AB */
    double distance = distance1 * sin(angle2); /* AQ */
    if (angle == 0) {
        /* Sanity check if AR and QBP are horizontal. */
        assert(fabs(distance - (ay - by)) < 0.1);
    }
    return distance;
}

/* A comparison function for use with qsort(), for sorting paragraphs within a
page. */
static int paras_cmp(const void* a, const void* b)
{
    para_t* const* a_para = a;
    para_t* const* b_para = b;
    line_t* a_line = para_line_first(*a_para);
    line_t* b_line = para_line_first(*b_para);

    span_t* a_span = line_span_first(a_line);
    span_t* b_span = line_span_first(b_line);

    /* If ctm matrices differ, always return this diff first. */
    int d = memcmp(&a_span->ctm, &b_span->ctm, sizeof(a_span->ctm));
    if (d)  return d;

    double a_angle = line_angle(a_line);
    double b_angle = line_angle(b_line);
    if (fabs(a_angle - b_angle) > 3.14/2) {
        /* Give up if more than 90 deg. */
        return 0;
    }
    double angle = (a_angle + b_angle) / 2;
    double ax = line_item_first(a_line)->x;
    double ay = line_item_first(a_line)->y;
    double bx = line_item_first(b_line)->x;
    double by = line_item_first(b_line)->y;
    double distance = line_distance(ax, ay, bx, by, angle);
    if (distance > 0)   return -1;
    if (distance < 0)   return +1;
    return 0;
}

/* Creates a representation of line_t's that consists of a list of para_t's.

We only join lines that are at the same angle and are adjacent.

On entry:
    Original value of *o_paras and *o_paras_num are ignored.

    <lines> points to array of <lines_num> line_t*'s, each pointing to a
    line_t.

On exit:
    On sucess, returns zero, *o_paras points to array of *o_paras_num
    para_t*'s, each pointing to a para_t. In the array, para_t's with same
    angle are sorted.

    On failure, returns -1 with errno set. *o_paras and *o_paras_num are
    undefined.
*/
static int make_paras(line_t** lines, int lines_num, para_t*** o_paras, int* o_paras_num)
{
    int ret = -1;
    para_t** paras = NULL;

    /* Start off with a para_t for each line_t. */
    int paras_num = lines_num;
    paras = malloc(sizeof(*paras) * paras_num);
    if (!paras) goto end;
    int a;
    /* Ensure we can clean up after error. */
    for (a=0; a<paras_num; ++a) {
        paras[a] = NULL;
    }
    for (a=0; a<paras_num; ++a) {
        paras[a] = malloc(sizeof(para_t));
        if (!paras[a]) goto end;
        paras[a]->lines_num = 0;
        paras[a]->lines = malloc(sizeof(line_t*) * 1);
        if (!paras[a]->lines) goto end;
        paras[a]->lines_num = 1;
        paras[a]->lines[0] = lines[a];
    }

    int num_joins = 0;
    for (a=0; a<paras_num; ++a) {

        para_t* para_a = paras[a];
        if (!para_a) {
            /* This para is empty - already been appended to a different para. */
            continue;
        }

        para_t* nearest_para = NULL;
        int nearest_para_b = -1;
        double nearest_para_distance = -1;
        assert(para_a->lines_num > 0);

        line_t* line_a = para_line_last(para_a);
        double angle_a = line_angle(line_a);

        /* Look for nearest run that could be appended to run_a. */
        int b;
        for (b=0; b<paras_num; ++b) {
            para_t* para_b = paras[b];
            if (!para_b) {
                /* This para is empty - already been appended to a different
                para. */
                continue;
            }
            line_t* line_b = para_line_first(para_b);
            if (!lines_are_compatible(line_a, line_b, angle_a)) {
                continue;
            }

            double ax = line_item_last(line_a)->x;
            double ay = line_item_last(line_a)->y;
            double bx = line_item_first(line_b)->x;
            double by = line_item_first(line_b)->y;
            double distance = line_distance(ax, ay, bx, by, angle_a);

            if (distance > 0) {
                if (nearest_para_distance == -1 || distance < nearest_para_distance) {
                    nearest_para_distance = distance;
                    nearest_para_b = b;
                    nearest_para = para_b;
                }
            }
        }

        if (nearest_para) {
            line_t* line_b = para_line_first(nearest_para);
            double line_b_size = line_font_size_max(para_line_first(nearest_para));
            if (0) fprintf(stderr, "joing paragraphs. a=(%lf,%lf) b=(%lf,%lf) nearest_para_distance=%lf line_b_size=%lf\n",
                    line_item_last(line_a)->x,
                    line_item_last(line_a)->y,
                    line_item_first(line_b)->x,
                    line_item_first(line_b)->y,
                    nearest_para_distance,
                    line_b_size
                    );
            if (nearest_para_distance < 1.5 * line_b_size) {
                /* Join these two para_t's. */
                span_t* a_span = line_span_last(line_a);
                if (span_char_last(a_span)->ucs == '-') {
                    /* remove trailing '-' at end of prev line. */
                    a_span->chars_num -= 1;
                }
                else {
                    /* Insert space before joining adjacent lines. */
                    if (span_append_c(line_span_last(line_a), ' ')) goto end;
                }

                int a_lines_num_new = para_a->lines_num + nearest_para->lines_num;
                line_t** l = realloc(para_a->lines, sizeof(line_t*) * a_lines_num_new);
                if (!l) goto end;
                para_a->lines = l;
                int i;
                for (i=0; i<nearest_para->lines_num; ++i) {
                    para_a->lines[para_a->lines_num + i] = nearest_para->lines[i];
                }
                para_a->lines_num = a_lines_num_new;

                /* Ensure that we skip nearest_para in future. */
                free(nearest_para->lines);
                free(nearest_para);
                paras[nearest_para_b] = NULL;
                //nearest_para->lines = NULL;
                //nearest_para->lines_num = 0;

                num_joins += 1;
                if (0) fprintf(stderr, "have joined para a=%i to snearest_para_b=%i\n", a, nearest_para_b);

                if (nearest_para_b > a) {
                    /* We haven't yet tried appending any paras to
                    nearest_para_b, so the new extended para_a needs checking
                    again. */
                    a -= 1;
                }
            }
        }
    }

    /* Remove empty paragraphs. */
    int from;
    int to;
    for (from=0, to=0; from<paras_num; ++from) {
        if (paras[from]) {
            paras[to] = paras[from];
            to += 1;
        }
    }
    if (0) fprintf(stderr, "paras_num=%i => %i\n", paras_num, to);
    paras_num = to;
    para_t** p = realloc(paras, sizeof(para_t*) * paras_num);
    assert(p); /* Should always succeed because we're not increasing allocation size. */
    paras = p;

    /* Sort paragraphs. */
    qsort(paras, paras_num, sizeof(para_t*), paras_cmp);

    *o_paras = paras;
    *o_paras_num = paras_num;
    ret = 0;
    if (0) fprintf(stderr, "Have made %i joins out of %i paras\n", num_joins, paras_num);

    end:

    if (ret) {
        for (a=0; a<paras_num; ++a) {
            if (paras[a])   free(paras[a]->lines);
            free(paras[a]);
        }
        free(paras);
    }
    return ret;
}



typedef struct
{
    span_t**    spans;
    int         spans_num;

    /*  lines->... eventually points to items in .spans. */
    line_t**    lines;
    int         lines_num;

    /*  pras->... eventually points to items in .lines. */
    para_t**    paras;
    int         paras_num;
} page_t;

static void page_init(page_t* page)
{
    page->spans = NULL;
    page->spans_num = 0;
    page->lines = NULL;
    page->lines_num = 0;
    page->paras = NULL;
    page->paras_num = 0;
}

static void page_free(page_t* page)
{
    if (!page) return;

    int s;
    for (s=0; s<page->spans_num; ++s) {
        span_t* span = page->spans[s];
        if (span) {
            free(span->chars);
            free(span->font_name);
        }
        free(span);
    }
    free(page->spans);

    int l;
    for (l=0; l<page->lines_num; ++l) {
        line_t* line = page->lines[l];
        free(line->spans);
        free(line);
        /* We don't free line->spans->chars[] because already freed via
        page->spans. */
    }
    free(page->lines);

    int p;
    for (p=0; p<page->paras_num; ++p) {
        para_t* para = page->paras[p];
        if (para) free(para->lines);
        free(para);
    }
    free(page->paras);
}

/* Appends new span_ to a page_t; returns NULL with errno set on error. */
static span_t* page_span_append(page_t* page)
{
    span_t* span = malloc(sizeof(*span));
    if (!span) return NULL;
    span->font_name = NULL;
    span->chars = NULL;
    span->chars_num = 0;
    span_t** s = realloc(page->spans, sizeof(*s) * (page->spans_num + 1));
    if (!s) {
        free(span);
        return NULL;
    }
    page->spans = s;
    page->spans[page->spans_num] = span;
    page->spans_num += 1;
    return span;
}

typedef struct {
    page_t**    pages;
    int         pages_num;
} document_t;

static void document_init(document_t* document)
{
    document->pages = NULL;
    document->pages_num = 0;
}

/* Appends new page_t to a document_t; returns NULL with errno set on error. */
static page_t* document_page_append(document_t* document)
{
    page_t* page = malloc(sizeof(page_t));
    if (!page) return NULL;
    page->spans = NULL;
    page->spans_num = 0;
    page->lines = NULL;
    page->lines_num = 0;
    page->paras = NULL;
    page->paras_num = 0;
    page_t** pages = realloc(document->pages, sizeof(page_t*) * (document->pages_num + 1));
    if (!pages) {
        free(page);
        return NULL;
    }
    document->pages = pages;
    page_init(page);
    document->pages[document->pages_num] = page;
    document->pages_num += 1;
    return page;
}

static void document_free(document_t* document)
{
    int p;
    for (p=0; p<document->pages_num; ++p) {
        page_t* page = document->pages[p];
        page_free(page);
        free(page);
    }
    free(document->pages);
    document->pages = NULL;
    document->pages_num = 0;
}

/* Does preliminary processing of the end of the last spen in a page; intended
to be called as we load span information.

Looks at last two char_t's in last span_t of <page>, and either leaves
unchanged, or removes space in last-but-one position, or moves last char_t into
a new span_t. */
static int page_span_end_clean( page_t* page)
{
    int ret = -1;
    assert(page->spans_num);
    span_t* span = page->spans[page->spans_num-1];
    assert(span->chars_num);
    char_t* char_ = &span->chars[span->chars_num - 1];
    if (span->chars_num == 1) {
        return 0;
    }

    float font_size = fz_matrix_expansion(span->trm);

    fz_point dir;
    if (span->wmode) {
        dir.x = 0;
        dir.y = 1;
    }
    else {
        dir.x = 1;
        dir.y = 0;
    }
    dir = fz_transform_vector(dir, span->trm);

    float x = char_[-1].x + char_[-1].adv * dir.x;
    float y = char_[-1].y + char_[-1].adv * dir.y;

    float err_x = (char_->x - x) / font_size;
    float err_y = (char_->y - y) / font_size;
    if (0) fprintf(stderr, "ucs=%c pos=(%f, %f) char_=(%f, %f) err=(%f, %f) adv=%f\n",
            char_->ucs,
            x, y,
            char_->x, char_->y,
            err_x, err_y,
            char_->adv
            );

    if (1
            && span->chars_num >= 2
            && span->chars[span->chars_num-2].ucs == ' '
            && err_x < -span->chars[span->chars_num-2].adv / 2
            && err_x > -span->chars[span->chars_num-2].adv
            ) {
        /* This character overlaps with previous space
        character. We discard previous space character - these
        sometimes seem to appear in the middle of words for some
        reason. */
        if (0) fprintf(stderr, "removing space\n");
        span->chars[span->chars_num-2] = span->chars[span->chars_num-1];
        span->chars_num -= 1;
        return 0;
    }
    else if (fabs(err_x) > 0.01 || fabs(err_y) > 0.01) {
        /* This character doesn't seem to be a continuation of
        previous characters, so split into two spans. This often
        splits text incorrectly, but this is corrected later when
        we join spans into lines. */
        if (0) {
            fprintf(stderr, "Splitting into new span. err=(%f, %f) pos=(%f, %f): ",
                    err_x, err_y,
                    x, y
                    );
            #if 0
            if (0) {
                int j;
                for (j=i<10; j<i+10; ++j) {
                    if (j < 0) continue;
                    if (j >= span->chars_num) break;
                    fprintf(stderr, "%c%c",
                            (j==i) ? '_' : ' ',
                            span->chars[j].ucs
                            );
                }
            }
            #endif
            fprintf(stderr, "\n");
        }
        span_t* span2 = page_span_append(page);
        if (!span2) goto end;
        *span2 = *span;
        span2->font_name = local_strdup(span->font_name);
        if (!span2->font_name) goto end;
        span2->chars_num = 1;
        span2->chars = malloc(sizeof(char_t) * span2->chars_num);
        if (!span2->chars) goto end;
        span2->chars[0] = *char_;

        char_ = &span2->chars[0];

        span->chars_num -= 1;
        return 0;
    }
    ret = 0;
    end:
    return ret;
}

/* Reads from 'raw' device output into document_t. */
static int read_spans_raw(const char* path, document_t *document)
{
    int ret = -1;

    FILE* in = NULL;
    document_init(document);

    in = pparse_init(path);
    if (!in) {
        fprintf(stderr, "Failed to open: %s\n", path);
        goto end;
    }
    xml_tag_t   tag;
    xml_tag_init(&tag);

    /* Data read from <path> is expected to be XML looking like:

    <page>
        <span>
            <span_item ...>
            <span_item ...>
            ...
        </span>
        <span>
            ...
        </span>
        ...
    </page>
    <page>
        ...
    </page>
    ...

    We convert this into a list of page_t's, each containing a list of
    span_t's, each containing a list of span_element_t's.

    While doing this, we do some within-span processing:
        We remove spurious spaces.
        We split spans in two where there seem to be large gaps.
    */
    for(;;) {
        int e = pparse_next(in, &tag);
        if (e == 1) break; /* EOF. */
        if (e) goto end;
        if (strcmp(tag.name, "page")) {
            fprintf(stderr, "Expected <page> but tag.name='%s'\n", tag.name);
            errno = ESRCH;
            goto end;
        }
        if (0) fprintf(stderr, "loading spans for page %i...\n", document->pages_num);
        page_t* page = document_page_append(document);
        if (!page) goto end;

        for(;;) {
            if (pparse_next(in, &tag)) goto end;
            if (!strcmp(tag.name, "/page")) {
                break;
            }
            if (strcmp(tag.name, "span")) {
                fprintf(stderr, "Expected <span> but tag.name='%s'\n", tag.name);
                errno = ESRCH;
                goto end;
            }

            span_t* span = page_span_append(page);
            if (!span) goto end;

            s_read_matrix(xml_tag_attributes_find(&tag, "ctm"), &span->ctm);
            s_read_matrix(xml_tag_attributes_find(&tag, "trm"), &span->trm);
            char* f = xml_tag_attributes_find(&tag, "font_name");
            char* ff = strchr(f, '+');
            if (ff)  f = ff + 1;
            span->font_name = local_strdup(f);
            if (!span->font_name) goto end;
            span->font_bold = strstr(span->font_name, "-Bold") ? 1 : 0;
            span->font_italic = strstr(span->font_name, "-Oblique") ? 1 : 0;
            if (xml_tag_attributes_find_int(&tag, "wmode", &span->wmode)) goto end;

            for(;;) {
                if (pparse_next(in, &tag)) goto end;
                if (!strcmp(tag.name, "/span")) {
                    break;
                }
                if (strcmp(tag.name, "span_item")) {
                    errno = ESRCH;
                    fprintf(stderr, "Expected <span_item> but tag.name='%s'\n", tag.name);
                    goto end;
                }
                if (span_append_c(span, 0 /*c*/)) goto end;
                char_t* char_ = &span->chars[ span->chars_num-1];
                if (xml_tag_attributes_find_float(&tag, "x", &char_->x)) goto end;
                if (xml_tag_attributes_find_float(&tag, "y", &char_->y)) goto end;
                if (xml_tag_attributes_find_float(&tag, "adv", &char_->adv)) goto end;
                if (xml_tag_attributes_find_int(&tag, "gid", &char_->gid)) goto end;
                if (xml_tag_attributes_find_int(&tag, "ucs", &char_->ucs)) goto end;

                if (page_span_end_clean(page)) goto end;
                span = page->spans[page->spans_num-1];
            }
            xml_tag_free(&tag);
        }
        if (0) fprintf(stderr, "page=%i page->num_spans=%i\n", document->pages_num, page->spans_num);
    }

    ret = 0;

    end:
    xml_tag_free(&tag);
    if (in) {
        fclose(in);
        in = NULL;
    }

    if (ret) {
        fprintf(stderr, "read_spans1() returning error\n");
        document_free(document);
    }

    return ret;
}


/* Reads from mupdf's trace-device into document_t. */
static int read_spans_trace(const char* path, document_t* document)
{
    int ret = -1;
    FILE* in = NULL;

    document_init(document);

    in = pparse_init(path);
    if (!in) {
        fprintf(stderr, "Failed to open: %s\n", path);
        goto end;
    }
    xml_tag_t   tag;
    xml_tag_init(&tag);

    int e = pparse_next(in, &tag);
    if (strcmp(tag.name, "document")) {
        fprintf(stderr, "expected '<document...>' but tag.name='%s'\n", tag.name);
        errno = ESRCH;
        goto end;
    }

    for(;;) {
        int e = pparse_next(in, &tag);
        if (e == 1) break; /* EOF. */
        if (e) goto end;
        if (!strcmp(tag.name, "/document")) {
            break;
        }
        if (strcmp(tag.name, "page")) {
            fprintf(stderr, "Expected <page> but tag.name='%s'\n", tag.name);
            errno = ESRCH;
            goto end;
        }
        page_t* page = document_page_append(document);
        if (!page) goto end;

        for(;;) {
            if (pparse_next(in, &tag)) goto end;
            if (!strcmp(tag.name, "/page")) {
                break;
            }
            if (strcmp(tag.name, "fill_text")) continue;
            fz_matrix   ctm;
            s_read_matrix(xml_tag_attributes_find(&tag, "transform"), &ctm);

            for(;;) {
                if (pparse_next(in, &tag)) goto end;
                if (!strcmp(tag.name, "/fill_text")) {
                    break;
                }
                if (strcmp(tag.name, "span")) {
                    fprintf(stderr, "Expected <span...> after <fill_text>, but tag.name='%s'\n", tag.name);
                    errno = ESRCH;
                    goto end;
                }
                span_t* span = page_span_append(page);
                if (!span) goto end;
                span->ctm = ctm;
                /* trace-device appears to only write first four members of
                fz_text_span::trm, on the assumption that .e and .f are zero,
                so we use s_read_matrix4() here. */
                s_read_matrix4(xml_tag_attributes_find(&tag, "trm"), &span->trm);
                char* f = xml_tag_attributes_find(&tag, "font");
                char* ff = strchr(f, '+');
                if (ff)  f = ff + 1;
                span->font_name = local_strdup(f);
                if (!span->font_name) goto end;
                span->font_bold = strstr(span->font_name, "-Bold") ? 1 : 0;
                span->font_italic = strstr(span->font_name, "-Oblique") ? 1 : 0;
                if (xml_tag_attributes_find_int(&tag, "wmode", &span->wmode)) goto end;

                for(;;) {
                    if (pparse_next(in, &tag)) goto end;
                    if (!strcmp(tag.name, "/span")) {
                        break;
                    }
                    if (strcmp(tag.name, "g")) {
                        errno = ESRCH;
                        fprintf(stderr, "Expected <g> but tag.name='%s'\n", tag.name);
                        goto end;
                    }
                    if (span_append_c(span, 0 /*c*/)) goto end;
                    char_t* char_ = &span->chars[ span->chars_num-1];
                    char_->x    = atof(xml_tag_attributes_find(&tag, "x"));
                    char_->y    = atof(xml_tag_attributes_find(&tag, "y"));
                    char_->gid  = 0;
                    if (xml_tag_attributes_find_int(&tag, "ucs", &char_->ucs)) goto end;
                    if (xml_tag_attributes_find_float(&tag, "adv", &char_->adv)) goto end;

                    if (page_span_end_clean(page)) goto end;
                    span = page->spans[page->spans_num-1];
                }
            }
        }
        if (0) fprintf(stderr, "page=%i page->num_spans=%i\n", document->pages_num, page->spans_num);
    }

    ret = 0;

    end:
    xml_tag_free(&tag);
    if (in) {
        fclose(in);
        in = NULL;
    }

    if (ret) {
        fprintf(stderr, "read_spans1() returning error\n");
        document_free(document);
    }

    return ret;
}


/* Writes paragraphs from document_t into docx content. On return
*content points to zero-terminated content, allocated by realloc(). */
static int paras_to_content(document_t* document, string_t* content)
{
    int ret = -1;

    /* Write paragraphs into <content>. */
    int p;
    for (p=0; p<document->pages_num; ++p) {
        page_t* page = document->pages[p];

        const char* font_name = NULL;
        float       font_size = 0;
        int         font_bold = 0;
        int         font_italic = 0;
        int p;
        for (p=0; p<page->paras_num; ++p) {
            para_t* para = page->paras[p];
            if (0) fprintf(stderr, "\n[para] ");
            if (docx_paragraph_start(content)) goto end;

            int l;
            for (l=0; l<para->lines_num; ++l) {
                line_t* line = para->lines[l];
                if (0) fprintf(stderr, " [line] ");
                int s;
                for (s=0; s<line->spans_num; ++s) {
                    span_t* span = line->spans[s];
                    if (0) {
                        fprintf(stderr, " [span ");
                        if (!font_name || strcmp(span->font_name, font_name)) {
                            fprintf(stderr, "%s", span->font_name);
                        }
                        if (span->font_bold != font_bold || span->font_italic != font_italic) {
                            if (0) fprintf(stderr, " %c%c",
                                    span->font_bold ? 'b':'-',
                                    span->font_italic ? 'i' : '-'
                                    );
                        }
                        fprintf(stderr, "]");
                    }
                    if (!font_name
                            || strcmp(span->font_name, font_name)
                            || fz_matrix_expansion(span->trm) != font_size
                            || span->font_bold != font_bold
                            || span->font_italic != font_italic
                            ) {
                        if (font_name) {
                            if (docx_run_finish(content)) goto end;
                            if (0) fprintf(stderr, " [font %s:%lf:%c%c] ",
                                    span->font_name,
                                    fz_matrix_expansion(span->trm),
                                    span->font_bold ? 'b' : '-',
                                    span->font_italic ? 'i' : '-'
                                    );
                        }
                        if (0) fprintf(stderr, " [%s %c%c] ",
                                span->font_name,
                                span->font_bold ? 'b':'-',
                                span->font_italic ? 'i' : '-'
                                );
                        font_name = span->font_name;
                        font_bold = span->font_bold;
                        font_italic = span->font_italic;
                        font_size = fz_matrix_expansion(span->trm);
                        if (docx_run_start(content, font_name, font_size, font_bold, font_italic)) goto end;
                    }

                    int si;
                    for (si=0; si<span->chars_num; ++si) {
                        char_t* char_ = &span->chars[si];
                        if (0) fprintf(stderr, "%c", char_->ucs);
                        if (0) fprintf(stderr, "[char_] %c (%f, %f)\n",
                                char_->ucs,
                                char_->x,
                                char_->y
                                );
                        int c = char_->ucs;
                        if (0) {}

                        /* Escape XML special characters. */
                        else if (c == '<')  docx_char_append_string(content, "&lt;");
                        else if (c == '>')  docx_char_append_string(content, "&gt;");
                        else if (c == '&')  docx_char_append_string(content, "&amp;");
                        else if (c == '"')  docx_char_append_string(content, "&quot;");
                        else if (c == '\'') docx_char_append_string(content, "&apos;");

                        /* Expand ligatures. */
                        else if (c == 0xFB00) {
                            if (docx_char_append_string(content, "ff")) goto end;
                        }
                        else if (c == 0xFB01) {
                            if (docx_char_append_string(content, "fi")) goto end;
                        }
                        else if (c == 0xFB02) {
                            if (docx_char_append_string(content, "fl")) goto end;
                        }
                        else if (c == 0xFB03) {
                            if (docx_char_append_string(content, "ffi")) goto end;
                        }
                        else if (c == 0xFB04) {
                            if (docx_char_append_string(content, "ffl")) goto end;
                        }

                        /* Output ASCII verbatim. */
                        else if (c >= 32 && c <= 127) {
                            if (docx_char_append_char(content, c)) goto end;
                        }

                        /* Escape all other characters. */
                        else {
                            char    buffer[32];
                            snprintf(buffer, sizeof(buffer), "&#x%x;", c);
                            if (docx_char_append_string(content, buffer)) goto end;
                        }
                    }
                    /* Remove any trailing '-' at end of line. */
                    if (docx_char_truncate_if(content, '-')) goto end;
                }
            }
            if (0) fprintf(stderr, "\n");
            if (font_name) {
                if (docx_run_finish(content)) goto end;
                font_name = NULL;
            }
            if (docx_paragraph_finish(content)) goto end;
        }
    }
    ret = 0;

    end:

    /* Free everything. */
    document_free(document);

    return ret;
}

/* Reads from intermediate data and converts into docx content. On return
*content points to zero-terminated content, allocated by realloc(). */
static int document_to_docx_content(document_t* document, string_t* content)
{
    int ret = -1;

    /* Now for each page we join spans into lines and paragraphs. A line is a
    list of spans that are at the same angle and on the same line. A paragraph
    is a list of lines that are at the same angle and close together. */
    int p;
    for (p=0; p<document->pages_num; ++p) {
        if (0) fprintf(stderr, "==[page %i]:\n", p);
        page_t* page = document->pages[p];

        if (make_lines(page->spans, page->spans_num, &page->lines, &page->lines_num)) goto end;

        if (make_paras(page->lines, page->lines_num, &page->paras, &page->paras_num)) goto end;
    }

    if (paras_to_content(document, content)) goto end;

    ret = 0;

    end:

    /* Free everything. */
    document_free(document);

    return ret;
}




/* Things to allow creation of a fz_context*. */

static pthread_mutex_t     m_mutexes[FZ_LOCK_MAX];
static fz_locks_context    m_locks;

static void lock(void *user, int lock)
{
    pthread_mutex_lock(&m_mutexes[lock]);
}

static void unlock(void *user, int lock)
{
    pthread_mutex_unlock(&m_mutexes[lock]);
}


int main(int argc, char** argv)
{
    const char* docx_out_path       = NULL;
    const char* input_path          = NULL;
    const char* docx_template_path  = NULL;
    const char* content_path        = NULL;
    int         preserve_dir        = 0;
    const char* method              = NULL;

    for (int i=1; i<argc; ++i) {
        const char* arg = argv[i];
        if (!strcmp(arg, "-h") || !strcmp(arg, "--help")) {
            printf(
                    "Generates a .docx file.\n"
                    "\n"
                    "Input:\n"
                    "\n"
                    "    We require a file containing XML output from: mutool draw -F <device>\n"
                    "    - where <device> is 'raw' or 'trace'.\n"
                    "\n"
                    "    We also requires a template .docx file\n"
                    "\n"
                    "Args:\n"
                    "    -c <path>\n"
                    "        If specified, we write raw .docx content to <path>; this is the\n"
                    "        text that we embed inside the template word/document.xml file\n"
                    "        when generating the .docx.\n"
                    "    -m <method>\n"
                    "        How to extract information from pdf document:\n"
                    "            raw\n"
                    "                <input-path> is from 'raw' device; use native conversion.\n"
                    "            trace\n"
                    "                <input-path> is from 'trace' device; use native conversion.\n"
                    "            stext\n"
                    "                <input-path> is from 'raw' device; use in-built stext\n"
                    "                conversion.\n"
                    "    -i <input-path>\n"
                    "        Name of XML file containing low-level text spans.\n"
                    "    -o <docx-path>\n"
                    "        Output .docx file.\n"
                    "    -p 0|1\n"
                    "        If 1, we preserve uncompressed <docx-path>.lib/ directory.\n"
                    "    -t <docx-template>\n"
                    "        Name of docx file to use as template.\n"
                    );
        }
        else if (!strcmp(arg, "-c")) {
            content_path = argv[++i];
        }
        else if (!strcmp(arg, "-m")) {
            method = argv[++i];
        }
        else if (!strcmp(arg, "-i")) {
            input_path = argv[++i];
        }
        else if (!strcmp(arg, "-o")) {
            docx_out_path = argv[++i];
        }
        else if (!strcmp(arg, "-p")) {
            preserve_dir = atoi(argv[++i]);
        }
        else if (!strcmp(arg, "-t")) {
            docx_template_path = argv[++i];
        }
        else {
            printf("Unrecognised arg: '%s'\n", arg);
            return 1;
        }

        assert(i < argc);
    }

    assert(input_path);
    assert(docx_out_path);
    assert(docx_template_path);

    int e = -1;
    string_t content;
    string_init(&content);
    document_t  document;
    document_init(&document);

    if (!method) {
        fprintf(stderr, "Must specify -m <method>\n");
        errno = ESRCH;
        goto end;
    }
    else if (!strcmp(method, "stext")) {
        fprintf(stderr, "Using stext to do main extraction\n");
        m_locks.user = NULL;
        m_locks.lock = lock;
        m_locks.unlock = unlock;
        int i;
        for (i=0; i<FZ_LOCK_MAX; ++i) {
            pthread_mutex_init(&m_mutexes[i], NULL /*attr*/);
        }
        fz_context* ctx = fz_new_context(NULL /*alloc*/, &m_locks, FZ_STORE_DEFAULT);

        stext_dev_and_page dev_page = spans_to_stext_device(ctx, input_path);

        page_to_docx_content(ctx, dev_page.page, &content);

        fz_close_device(ctx, &dev_page.dev->super);
        fz_drop_device(ctx, &dev_page.dev->super);
        fz_drop_stext_page(ctx, dev_page.page);

        fz_drop_context(ctx);
    }
    else if (!strcmp(method, "trace")) {
        if (read_spans_trace(input_path, &document)) {
            fprintf(stderr, "Failed to read 'trace' output from: %s\n", input_path);
            goto end;
        }
        if (document_to_docx_content(&document, &content)) {
            fprintf(stderr, "Failed to create docx content errno=%i: %s\n", errno, strerror(errno));
            goto end;
        }
    }
    else if (!strcmp(method, "raw")) {
        if (read_spans_raw(input_path, &document)) {
            fprintf(stderr, "Failed to read 'raw' output from: %s\n", input_path);
            goto end;
        }
        if (document_to_docx_content(&document, &content)) {
            fprintf(stderr, "Failed to create docx content errno=%i: %s\n", errno, strerror(errno));
            return 1;
        }
    }
    else {
        fprintf(stderr, "Unrecognised method '%s'\n", method);
        errno = ESRCH;
        goto end;
    }

    if (content_path) {
        fprintf(stderr, "Writing content to: %s\n", content_path);
        FILE* f = fopen(content_path, "w");
        assert(f);
        fwrite(content.chars, content.chars_num, 1 /*nmemb*/, f);
        fclose(f);
    }
    fprintf(stderr, "Creating .docx file: %s\n", docx_out_path);
    e = docx_create(&content, docx_out_path, docx_template_path, preserve_dir);

    end:

    string_free(&content);
    document_free(&document);

    fprintf(stderr, "Finished, e=%i\n", e);

    return e;
}
